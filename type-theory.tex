\input{preamble}

% OK, start here.
%
\input{chapter_modifications.tex}
\begin{document}

\title{Type Theory}

\maketitle

\phantomsection
\label{section-phantom}

This chapter contains material on type theory.

\ChapterTableOfContents

TODO:
\begin{enumerate}
    \item \url{https://mathoverflow.net/questions/499517/models-of-hott-locally-ccc-vs-quillen}
    \item Multiplication
    \item Exponentiation
    \item Min and max functions
    \item Maybe: Factorials
    \item Maybe: Binomial coefficients
    \item Maybe: Predecessor function
    \item $\mathsf{neg}_{\Z}\oftype\Z\to\Z$ (antipode)
    \item Distributive-inv-concat, $(q\ccirc p)^{-1}=p^{-1}\ccirc q^{-1}$.
    \item inv-con and con-inv $(q\ccirc p\equals r)\to(q\equals p^{-1}\ccirc r)$
    \item lift $\mathsf{lift}_{B}(p,b)\oftype (a,b)=(x,\sftr_{B}(p,b))$
    \item mac lane pentagon
    \item multiplication distributes over addition
    \item $\leq$ (6.3)
    \item maybe: absolute value
    \item maybe: distance
    \item Homotopy linear type theory | Programming languages with homotopy types
\end{enumerate}

\section{Type Theory Basics}\label{section-type-theory-basics}
\subsection{Inference Rules}\label{subsection-inference-rules}
\begin{definition}{Inference Rules}{inference-rules}%
    An \index[type-theory]{inference rule}\textbf{inference rule} is written in the form
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\mathcal{H}_{1}}%
            \hypo{\mathcal{H}_{2}}%
            \hypo{\ldots}%
            \hypo{\mathcal{H}_{n}}%
            \infer4[(name)]{\mathcal{C}}
        \end{prooftree}%
    \end{webprooftree}%
    and represents a deduction going from a finite list $\mathcal{H}_{1}$, $\ldots$, $\mathcal{H}_{n}$ of \textbf{judgements} for the \textbf{premises} to a \textbf{conclusion} $\CatFont{C}$, which is itself a (single) judgement.
\end{definition}
\begin{example}{An Inference Rule for Function Types}{an-inference-rule-for-function-types}%
    The inference rule
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{a\oftype A}}%
            \hypo{\context{\Gamma}{f\oftype A\to B}}%
            \infer2[(ev2)]{\context{\Gamma}{f(a)\oftype B}}%
        \end{prooftree}%
    \end{webprooftree}%
    works as follows. In the \emph{context} $\Gamma$, we start with:
    \begin{itemize}
        \item A term $a$ of type $A$;
        \item A term $f$ of type $A\to B$;
    \end{itemize}
    and then obtain a term $f(a)$ of type $B$.
\end{example}
\subsection{Contexts}\label{subsection-contexts}
\begin{definition}{Contexts}{contexts}%
    A \index[type-theory]{context}\textbf{context} is a finite list%
    %--- Begin Footnote ---%
    \footnote{%
        There is, in particular, the empty context.
        \par\vspace*{\TCBBoxCorrection}
    } %
    %---  End Footnote  ---%
    of \textbf{variable declarations}
    \begin{itemize}
        \item $a_{1}\oftype A_{1}$;
        \item $a_{2}\oftype A_{2}(x_{1})$;
        \item $\ldots$;
        \item $a_{k}\oftype A_{k}(x_{k-1})$;
    \end{itemize}
    such that, for each $1\leq k\leq n$, we may derive the judgement
    \[
        \context{x\oftype A_{1},\ldots,x_{k-1}\oftype A_{k-1}(x_{1},\ldots,x_{k-2})}{A_{k}(x_{1},\ldots,x_{k-1})\type}.%
    \]%
\end{definition}
\subsection{Type Families}\label{subsection-type-families}
\begin{definition}{Type Families and Sections}{type-families-and-sections}%
    Let $A$ be a type in a context $\Gamma$.
    \begin{enumerate}
        \item\label{type-families-and-sections-type-families}A \index[type-theory]{type family}\textbf{family of types over} $A$ in context $\Gamma$ is a type $B(x)$ in context $\Gamma,\,x\oftype A$.%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Further Terminology: }We also say that $B(x)$ is a type \textbf{indexed} by $x\oftype A$ in context $\Gamma$.
            }%
            %---  End Footnote  ---%
        \item\label{type-families-and-sections-sections}A \index[type-theory]{section}\textbf{section} of a type family $B$ over $A$ in context $\Gamma$ is a term $b(x)$ of type $B(x)$ in context $\Gamma,\,x\oftype A$.%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Further Terminology: }We also say that $b(x)$ is a term of type $B(x)$ \textbf{indexed} by $x\oftype A$ in context $\Gamma$.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
    \end{enumerate}
\end{definition}
\begin{example}{Identity Types}{identity-types}%
    Identity types are introduced as
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{a\oftype A}}%
            \infer1[(id-form)]{\context{\Gamma,\,x\oftype A}{a\equals_{A}x\type}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    So $a\equals_{A}x$ is a type indexed over $x\oftype A$.
\end{example}
\subsection{Derivations}\label{subsection-derivations}
\begin{definition}{Derivations}{derivations}%
    A \index[type-theory]{derivation}\textbf{derivation} is a finite tree having rules of inference as nodes.
\end{definition}
\begin{example}{Changing Variables in Martin-Löf Type Theory}{changing-variables-in-martin-löf-type-theory}%
    The inference rule
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{\mathcal{J}}}%
            \infer1[(CV)]{\context{\Gamma,\,a\oftype A,\,\Delta[a/x]}{\mathcal{J}[a/x]}}%
        \end{prooftree}%
    \end{webprooftree}%
    admits the following derivation:
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \infer1[(G)]{\context{\Gamma,\,a\oftype A}{a\oftype A}}%
            \hypo{\context{\Gamma,\,x\oftype A}{\mathcal{J}}}%
            \infer1[(W)]{\context{\Gamma,\,x\oftype A,\,a\oftype A,\,\Delta}{\mathcal{J}}}%
            \infer2[(S)]{\context{\Gamma,\,a\oftype A,\,\Delta[a/x]}{\mathcal{J}[a/x]}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
\end{example}
\begin{example}{Interchanging Variables in Martin-Löf Type Theory}{interchanging-variables-in-martin-löf-type-theory}%
    The inference rule
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{B\type}}%
            \hypo{\context{\Gamma,\,x\oftype A,\,y\oftype B,\,\Delta}{\mathcal{J}}}%
            \infer2[(IV)]{\context{\Gamma,\,y\oftype B,\,x\oftype A,\,\Delta}{\mathcal{J}}}%
        \end{prooftree}%
    \end{webprooftree}%
    admits the following derivation:
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{B\type}}%
            \infer1[(G)]{\context{\Gamma,\,y\oftype B}{y\oftype B}}%
            \infer1[(W)]{\context{\Gamma,\,y\oftype B,\,x\oftype A}{y\oftype B}}%
            \hypo{\context{\Gamma}{B\type}}%
            \hypo{\context{\Gamma,\,x\oftype A,\,y\oftype B,\,\Delta}{\mathcal{J}}}%
            \infer1[(CV)]{\context{\Gamma,\,x\oftype A,\,y'\oftype B,\,\Delta[y'/y]}{\mathcal{J}[y'/y]}}%
            \infer2[(W)]{\context{\Gamma,\,y\oftype B,\,x\oftype A,\,y'\oftype B,\,\Delta[y'/y]}{\mathcal{J}[y'/y]}}%
            \infer2[(S)]{\context{\Gamma,\,y\oftype B,\,x\oftype A,\,\Delta}{\mathcal{J}}}
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
\end{example}
\section{Martin-Löf Type Theory}\label{section-martin-löf-type-theory}
\subsection{Judgements}\label{subsection-the-judgements-of-martin-löf-type-theory}
\begin{definition}{Judgements in Martin-Löf Type Theory}{judgements-in-martin-löf-type-theory}%
    Martin-Löf type theory has four kinds of \textbf{judgements}:
    \begin{enumerate}
        \item\label{martin-löf-type-theory-being-a-type}$A$ is a \textbf{type} in context $\Gamma$.
        \item\label{martin-löf-type-theory-being-judgementally-equal-types}$A$ and $B$ are \textbf{judgementally equal types} in context $\Gamma$.
        \item\label{martin-löf-type-theory-being-a-term}$a$ is a \textbf{term} of type $A$ in context $\Gamma$.
        \item\label{martin-löf-type-theory-being-judgementally-equal-terms}Terms $a$ and $b$ of type $A$ are \textbf{judgementally equal terms} of type $A$ in context $\Gamma$.
    \end{enumerate}
    These four judgements are written as follows:
    \begin{itemize}
        \item $\context{\Gamma}{A\type}$.
        \item $\context{\Gamma}{A\doteq B\type}$.
        \item $\context{\Gamma}{a\oftype A}$.
        \item $\context{\Gamma}{a\doteq b\oftype A}$.
    \end{itemize}
\end{definition}
\subsection{Formation of Contexts, Types, and Terms}\label{subsection-formation-of-contexts-types-and-terms}
\begin{definition}{Formation of Contexts, Types, and Terms in Martin-Löf Type Theory}{formation-of-contexts-types-and-terms-in-martin-löf-type-theory}%
    Martin-Löf type theory has the following inference rules about the formation of contexts, types, and terms.
    \begin{enumerate}
        \item\label{formation-of-contexts-types-and-terms-in-martin-löf-type-theory-formation-of-dependent-types}\SloganFont{Formation of Dependent Types. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A}{B(x)\type}}%
                    \infer1{\context{\Gamma}{A\type}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{formation-of-contexts-types-and-terms-in-martin-löf-type-theory-formation-of-judgemental-equality-of-types-1}\SloganFont{Formation of Judgemental Equality of Types \rmI. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\doteq B\type}}%
                    \infer1{\context{\Gamma}{A\type}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{formation-of-contexts-types-and-terms-in-martin-löf-type-theory-formation-of-judgemental-equality-of-types-1}\SloganFont{Formation of Judgemental Equality of Types \rmII. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\doteq B\type}}%
                    \infer1{\context{\Gamma}{B\type}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{formation-of-contexts-types-and-terms-in-martin-löf-type-theory-formation-of-terms}\SloganFont{Formation of Terms. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \infer1{\context{\Gamma}{A\type}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{formation-of-contexts-types-and-terms-in-martin-löf-type-theory-formation-of-judgemental-equality-of-terms-1}\SloganFont{Formation of Judgemental Equality of Terms \rmI. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\doteq b\oftype A}}%
                    \infer1{\context{\Gamma}{a\oftype A}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{formation-of-contexts-types-and-terms-in-martin-löf-type-theory-formation-of-judgemental-equality-of-terms-3}\SloganFont{Formation of Judgemental Equality of Terms \rmII. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\doteq b\oftype A}}%
                    \infer1{\context{\Gamma}{b\oftype A}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        %\item\label{formation-of-contexts-types-and-terms-in-martin-löf-type-theory-}\SloganFont{. }
    \end{enumerate}
\end{definition}
\subsection{Judgemental Equality}\label{subsection-judgemental-equality-in-martin-löf-type-theory}
\begin{definition}{Judgemental Equality in Martin-Löf Type Theory \rmII}{judgemental-equality-in-martin-löf-type-theory}%
    Martin-Löf type theory has the following inference rules about judgemental equality of types, ensuring it behaves like an equivalence relation.
    \begin{enumerate}
        \item\label{judgemental-equality-in-martin-löf-type-theory-reflexivity}\SloganFont{Reflexivity. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \infer1[(refl)]{\context{\Gamma}{A\doteq A\type}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{judgemental-equality-in-martin-löf-type-theory-symmetry}\SloganFont{Symmetry. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\doteq B\type}}%
                    \infer1[(symm)]{\context{\Gamma}{B\doteq A\type}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{judgemental-equality-in-martin-löf-type-theory-transitivity}\SloganFont{Transitivity. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\doteq B\type}}%
                    \hypo{\context{\Gamma}{B\doteq C\type}}%
                    \infer2[(trans)]{\context{\Gamma}{A\doteq C\type}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        %\item\label{judgemental-equality-in-martin-löf-type-theory-}\SloganFont{. }
    \end{enumerate}
\end{definition}
\begin{definition}{Inference Rules in Martin-Löf Type Theory \rmIII}{inference-rules-in-martin-löf-type-theory-3}%
    Martin-Löf type theory has the following inference rules about judgemental equality of terms, ensuring it behaves like an equivalence relation.
    \begin{enumerate}
        \item\label{inference-rules-in-martin-löf-type-theory-3-reflexivity}\SloganFont{Reflexivity. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A\type}}%
                    \infer1[(refl)]{\context{\Gamma}{a\doteq a\oftype A}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{inference-rules-in-martin-löf-type-theory-3-symmetry}\SloganFont{Symmetry. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\doteq b\oftype A}}%
                    \infer1[(symm)]{\context{\Gamma}{b\doteq a\oftype A}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{inference-rules-in-martin-löf-type-theory-3-transitivity}\SloganFont{Transitivity. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\doteq b\oftype A}}%
                    \hypo{\context{\Gamma}{b\doteq c\oftype A}}%
                    \infer2[(trans)]{\context{\Gamma}{a\doteq c\oftype A}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        %\item\label{inference-rules-in-martin-löf-type-theory-3-}\SloganFont{. }
    \end{enumerate}
\end{definition}
\subsection{Variable Conversion}\label{subsection-variable-conversion-in-martin-löf-type-theory}
\begin{definition}{Inference Rules in Martin-Löf Type Theory \rmIV}{variable-conversion-in-martin-löf-type-theory}%
    Martin-Löf type theory has the following inference rules about \textbf{variable conversion}. They postulate we may convert a variable to a judgementally equal type/term.\index[type-theory]{variable conversion rules}%
    \begin{enumerate}
        \item\label{variable-conversion-in-martin-löf-type-theory-variable-conversion-for-types}\SloganFont{Variable Conversion for Types. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Slogan: }We may reindex a type $B(x)$ over $x\oftype A$ to $x\oftype A'$ when $A\doteq A'\type$.
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{C(x)\type}}%
                    \hypo{\context{\Gamma}{A\doteq B\type}}%
                    \infer2{\context{\Gamma,\,x\oftype B,\,\Delta}{C(x)\type}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{variable-conversion-in-martin-löf-type-theory-variable-conversion-for-terms}\SloganFont{Variable Conversion for Terms. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Slogan: }If we have a term $c(x)$ of type $C(x)$ indexed by $x\oftype A$ and $A\doteq B\type$, then $c(x)$ will have type $C(x)$ indexed by $x\oftype B$.
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{c(x)\oftype C(x)}}%
                    \hypo{\context{\Gamma}{A\doteq B\type}}%
                    \infer2{\context{\Gamma,\,x\oftype B,\Delta}{c(x)\oftype C(x)}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{variable-conversion-in-martin-löf-type-theory-variable-conversion-for-judgemental-equality-of-types}\SloganFont{Variable Conversion for Judgemental Equality of Types. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Slogan: }We may transfer a judgemental equality $C(x)\doteq C'(x)\type$ indexed over $x\oftype A$ to a judgemental equality $C(x)\doteq C'(x)\type$ indexed over $x\oftype B$ when $A\doteq B\type$.
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{C(x)\doteq C'(x)\type}}%
                    \hypo{\context{\Gamma}{A\doteq B\type}}%
                    \infer2{\context{\Gamma,\,x\oftype B,\,\Delta}{C(x)\doteq C'(x)\type}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{variable-conversion-in-martin-löf-type-theory-variable-conversion-for-judgemental-equality-of-terms}\SloganFont{Variable Conversion for Judgemental Equality of Terms. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Slogan: }We may transfer a judgemental equality $c(x)\doteq c'(x)\oftype C(x)$ indexed over $x\oftype A$ to a judgemental equality $c(x)\doteq c'(x)\oftype C(x)$ indexed over $x\oftype B$ when $A\doteq B\type$.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{c(x)\doteq c'(x)\oftype C(x)}}%
                    \hypo{\context{\Gamma}{A\doteq B\type}}%
                    \infer2{\context{\Gamma,\,x\oftype B,\,\Delta}{c(x)\doteq c'(x)\oftype C(x)}}
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
    These rules may be summarised as
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{\mathcal{J}}}%
            \hypo{\context{\Gamma}{A\doteq B\type}}%
            \infer2[(VC)]{\context{\Gamma,\,x\oftype B,\,\Delta}{\mathcal{J}}}%
        \end{prooftree}%
    \end{webprooftree}%
    for $\mathcal{J}$ a \textit{generic judgement}.
\end{definition}
\begin{proposition}{More Variable Conversion Rules for Martin-Löf Type Theory}{more-variable-conversion-rules-for-martin-löf-type-theory}%
    Martin-Löf type theory has the following additional variable conversion rules:\index[type-theory]{variable conversion rules}%
    \begin{enumerate}
        \item\label{more-variable-conversion-rules-for-martin-löf-type-theory-converting-terms}\SloganFont{Converting Terms. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \hypo{\context{\Gamma}{A\doteq B\type}}%
                    \infer2[(CT)]{\context{\Gamma}{a\oftype B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{more-variable-conversion-rules-for-martin-löf-type-theory-converting-judgemental-equality-for-terms}\SloganFont{Converting Judgemental Equality for Terms. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\doteq b\oftype A}}%
                    \hypo{\context{\Gamma}{A\doteq B\type}}%
                    \infer2[(CJET)]{\context{\Gamma}{a\doteq b\oftype B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{more-variable-conversion-rules-for-martin-löf-type-theory}}%
    \FirstProofBox{\cref{more-variable-conversion-rules-for-martin-löf-type-theory-converting-terms}: Converting Terms}%
    We have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{a\oftype A}}%
            \hypo{\context{\Gamma}{A\doteq B\type}}%
            \infer1{\context{\Gamma}{B\type}}%
            \infer1[(G)]{\context{\Gamma,\,x\oftype B}{x\oftype B}}%
            \hypo{\context{\Gamma}{A\doteq B\type}}%
            \infer1[(symm)]{\context{\Gamma}{B\doteq A\type}}%
            \infer2[(VC)]{\context{\Gamma,\,x\oftype A}{x\oftype B}}%
            \infer2{\context{\Gamma}{a\oftype B}}
        \end{prooftree}%
        .%
    \end{webprooftree}%
    This finishes the proof.

    \ProofBox{\cref{more-variable-conversion-rules-for-martin-löf-type-theory-converting-judgemental-equality-for-terms}: Converting Judgemental Equality for Terms}%
    We have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{a\doteq b\oftype A}}%
            \hypo{\context{\Gamma}{A\doteq B\type}}%
            \infer1{\context{\Gamma}{B\type}}%
            \infer1[(G)]{\context{\Gamma,\,x\oftype B}{x\oftype B}}%
            \hypo{\context{\Gamma}{A\doteq B\type}}%
            \infer1[(symm)]{\context{\Gamma}{B\doteq A\type}}%
            \infer2[(VC)]{\context{\Gamma,\,x\oftype A}{x\oftype B}}%
            \infer2[(CS2)]{\context{\Gamma}{x[a/x]\doteq x[b/x]\oftype B[a/x]}}
            \infer1{\context{\Gamma}{a\doteq b\oftype B}}%
        \end{prooftree}%
        ,%
    \end{webprooftree}%
    where we have used \cref{inference-rules-in-martin-löf-type-theory-6-substitution-by-judgementally-equal-terms-for-types-2-terms} of \cref{inference-rules-in-martin-löf-type-theory-6} (CS2) from below.
\end{Proof}
\subsection{Substitution}\label{subsection-substitution-in-martin-löf-type-theory}
\begin{definition}{Substitution in Martin-Löf Type Theory}{substitution-in-martin-löf-type-theory}%
    Martin-Löf type theory has the following inference rules about \textbf{substitution}:\index[type-theory]{substitution rules}%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology and Notation: }The type $B[a/x]$ is the \index[type-theory]{fibre}\textbf{fibre} of $B$ at $a$, and is also written $B(a)$.
    }%
    %---  End Footnote  ---%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology and Notation: }The term $b[a/x]$ is the \index[type-theory]{value}\textbf{value} of $b(x)$ at $a$, and is also written $b(a)$.
        \par\vspace*{\TCBBoxCorrection}
    }%
    %---  End Footnote  ---%
    \begin{enumerate}
        \item\label{substitution-in-martin-löf-type-theory-substitution-in-types}\SloganFont{Substitution in Types. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{B(x)\type}}%
                    \infer2{\context{\Gamma,\,\Delta[a/x]}{B[a/x]\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{substitution-in-martin-löf-type-theory-substitution-in-terms}\SloganFont{Substitution in Terms. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{b(x)\oftype B(x)}}%
                    \infer2{\context{\Gamma,\,\Delta[a/x]}{b[a/x]\oftype B[a/x]}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{substitution-in-martin-löf-type-theory-substitution-in-judgemental-equality-of-types}\SloganFont{Substitution in Judgemental Equality of Types. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{B(x)\doteq C(x)\type}}%
                    \infer2{\context{\Gamma,\,\Delta[a/x]}{B[a/x]\doteq C[a/x]\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{substitution-in-martin-löf-type-theory-substitution-in-judgemental-equality-of-terms}\SloganFont{Substitution in Judgemental Equality of Terms. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{b(x)\doteq b'(x)\oftype B(x)}}%
                    \infer2{\context{\Gamma,\,\Delta[a/x]}{b[a/x]\doteq b'[a/x]\oftype B[a/x]}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        %\item\label{substitution-in-martin-löf-type-theory-}\SloganFont{. }
    \end{enumerate}
    These rules may be summarised as
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{a\oftype A}}%
            \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{\mathcal{J}}}%
            \infer2{\context{\Gamma,\,\Delta[a/x]}{\mathcal{J}[a/x]}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    for $\mathcal{J}$ a generic judgement.
\end{definition}
\begin{definition}{Inference Rules in Martin-Löf Type Theory \rmVI}{inference-rules-in-martin-löf-type-theory-6}%
    Martin-Löf type theory has the following additional \say{congruence} rules about \textbf{substitution}:\index[type-theory]{substitution rules}%
    \begin{enumerate}
        \item\label{inference-rules-in-martin-löf-type-theory-6-substitution-by-judgementally-equal-terms-for-types-1-types}\SloganFont{Substitution by Judgementally Equal Terms \rmI: Types. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\doteq b\oftype A}}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{C(x)\type}}%
                    \infer2[(CS1)]{\context{\Gamma,\,\Delta[a/x]}{C[a/x]\doteq C[b/x]\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{inference-rules-in-martin-löf-type-theory-6-substitution-by-judgementally-equal-terms-for-types-2-terms}\SloganFont{Substitution by Judgementally Equal Terms \rmII: Terms. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\doteq b\oftype A}}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,\Delta}{c(x)\oftype C(x)}}%
                    \infer2[(CS2)]{\context{\Gamma,\,\Delta[a/x]}{c[a/x]\doteq c[b/x]\oftype C[a/x]}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        %\item\label{inference-rules-in-martin-löf-type-theory-6-}\SloganFont{. }
    \end{enumerate}
\end{definition}
\subsection{Weakening}\label{subsection-weakening-in-martin-löf-type-theory}
\begin{definition}{Weakening in Martin-Löf Type Theory \rmVII}{weakening-in-martin-löf-type-theory}%
    Martin-Löf type theory has the following rules about \textit{weakening}:\index[type-theory]{weakening rule}%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology: }The type $B$ in context $\Gamma,\,x\oftype A$ is called the \textbf{constant family $B$} or the \textbf{trivial family $B$}.
        \par\vspace*{\TCBBoxCorrection}
    }%
    %---  End Footnote  ---%
    \begin{enumerate}
        \item\label{weakening-in-martin-löf-type-theory-weakening-for-types}\SloganFont{Weakening for Types. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B(x)\type}}%
                    \infer2{\context{\Gamma,\,a\oftype A}{B(x)\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{weakening-in-martin-löf-type-theory-weakening-for-terms}\SloganFont{Weakening for Terms. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{b(x)\oftype B(x)}}%
                    \infer2{\context{\Gamma,\,a\oftype A}{b(x)\oftype B(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{weakening-in-martin-löf-type-theory-weakening-for-judgemental-equality-of-types}\SloganFont{Weakening for Judgemental Equality of Types. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B(x)\doteq C(x)\type}}%
                    \infer2{\context{\Gamma,\,a\oftype A}{B(x)\doteq C(x)\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{weakening-in-martin-löf-type-theory-weakening-for-judgemental-equality-of-terms}\SloganFont{Weakening for Judgemental Equality of Terms. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{b(x)\doteq b'(x)\oftype B(x)}}%
                    \infer2{\context{\Gamma,\,a\oftype A}{b(x)\doteq b'(x)\oftype B(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        %\item\label{weakening-in-martin-löf-type-theory-}\SloganFont{. }
    \end{enumerate}
    These rules may be summarised as
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{\mathcal{J}}}%
            \infer2{\context{\Gamma,\,a\oftype A,\,\Delta}{\mathcal{J}}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    for $\mathcal{J}$ a generic judgement.
\end{definition}
\subsection{Generic Elements}\label{subsection-generic-elements-in-martin-löf-type-theory}
\begin{definition}{Generic Elements in Martin-Löf Type Theory}{generic-elements-in-martin-löf-type-theory}%
    Martin-Löf type theory has the following \textbf{variable rule} about the \textbf{generic element}:\index[type-theory]{generic element rule}%
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \infer1[(G)]{\context{\Gamma,\,x\oftype A}{x\oftype A}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
\end{definition}
\section{Functions in Martin-Löf Type Theory}\label{section-functions-in-martin-löf-type-theory}
\subsection{Dependent Function Types}\label{subsection-martin-löf-type-theory-dependent-function-types}
\begin{definition}{The Π-Formation Rule}{the-pi-formation-rule}%
    Martin-Löf type theory has the following inference rules about the formation of \index[type-theory]{Π-types}\textbf{Π-types}:\index[type-theory]{Π-formation rule}%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology: }Also called \index[type-theory]{dependent function types}\textbf{dependent function types}.
    }%
    %---  End Footnote  ---%
    \begin{enumerate}
        \item\label{the-pi-formation-rule-forming-pi-types}\SloganFont{Forming Π-Types. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Slogan: }We may form a Π-type $\prod_{x\oftype A}B(x)$ given a type family $B(x)$ indexed over $x\oftype A$.
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A}{B(x)\type}}%
                    \infer1[(Π-form)]{\context{\Gamma}{\displaystyle\prod_{x\oftype A}B(x)\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{the-pi-formation-rule-congruence-rule-for-the-formation-of-pi-types}\SloganFont{Congruence Rule for the Formation of Π-Types. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Slogan: }Formation of Π-types respects judgemental equality.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\doteq A'\type}}%
                    \hypo{\context{\Gamma,\,x\oftype A}{B(x)\doteq B'(x)\type}}%
                    \infer2[(Π-eq)]{\context{\Gamma}{\displaystyle\prod_{x\oftype A}B(x)\doteq\prod_{x\oftype A'}B'(x)\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{definition}
\begin{definition}{The Π-Introduction Rule}{the-pi-introduction-rule}%
    Martin-Löf type theory has the following inference rules about the construction of \index[type-theory]{dependent function}\textbf{dependent functions} of type a Π-type:\index[type-theory]{Π-introduction rule}%
    \begin{enumerate}
        \item\label{the-pi-introduction-rule-forming-terms-of-pi-types}\SloganFont{Forming Terms of Π-Types. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Further Terminology: }This rule is also called the \index[type-theory]{lambda-abstraction rule@λ-abstraction rule}\textbf{λ-abstraction rule}.
            }%
            %---  End Footnote  ---%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Further Terminology: }We say that the λ-abstraction $\lambda x\ldotp b(x)$ \textbf{binds} the variable $x$ to $b$.
            }%
            %---  End Footnote  ---%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Slogan: }To construct a dependent function $\lambda x\ldotp b(x)$ of type $\prod_{x\oftype A}B(x)$, we need to construct a term $b(x)\oftype B(x)$ indexed by $x\oftype A$.
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A}{b(x)\oftype B(x)}}%
                    \infer1[(λ)]{\context{\Gamma}{\displaystyle\lambda x\ldotp b(x)\oftype\prod_{x\oftype A}B(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{the-pi-introduction-rule-congruence-rule-for-the-formation-of-terms-of-pi-types}\SloganFont{Congruence Rule for the Formation of Terms of Π-Types. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Slogan: }Construction of dependent functions respects judgemental equality.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A}{b(x)\doteq b'(x)\oftype B(x)}}%
                    \infer1[(λ-eq)]{\context{\Gamma}{\displaystyle\lambda x\ldotp b(x)\doteq\lambda x\ldotp b'(x)\oftype\prod_{x\oftype A}B(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{definition}
\begin{notation}{λ-Notation}{lambda-notation}%
    In \cref{the-pi-introduction-rule}, we have used what is called λ-abstraction, $\lambda x\ldotp b(x)$, and we will also write it as $\llbracket\lambda\ldotp b(x)\rrbracket$ or $\llbracket x\mapsto b(x)\rrbracket$.

    \indent With this alternative notation, the inference rules in \cref{the-pi-introduction-rule-forming-terms-of-pi-types,the-pi-introduction-rule-congruence-rule-for-the-formation-of-terms-of-pi-types} of \cref{the-pi-introduction-rule} look like this:
    \begin{enumerate}
        \item\label{lambda-notation-forming-terms-of-pi-types}\SloganFont{Forming Terms of Π-Types. }We have%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A}{b(x)\oftype B(x)}}%
                    \infer1[(λ)]{\context{\Gamma}{\displaystyle\llbracket x\mapsto b(x)\rrbracket\oftype\prod_{x\oftype A}B(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{lambda-notation-congruence-rule-for-the-formation-of-terms-of-pi-types}\SloganFont{Congruence Rule for the Formation of Terms of Π-Types. }We have%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A}{b(x)\doteq b'(x)\oftype B(x)}}%
                    \infer1[(λ-eq)]{\context{\Gamma}{\displaystyle\llbracket x\mapsto b(x)\rrbracket\doteq\llbracket x\mapsto b'(x)\rrbracket\oftype\prod_{x\oftype A}B(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{notation}
\begin{definition}{The Π-Elimination Rule}{the-pi-elimination-rule}%
    Martin-Löf type theory has the following inference rules about the use of dependent functions:\index[type-theory]{Π-elimination rule}%
    \begin{enumerate}
        \item\label{the-pi-formation-rule-the-pi-elimination-rule}\SloganFont{The Π-Elimination Rule. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Further Terminology: }This rule is also called the \index[type-theory]{evaluation rule}\textbf{λ-abstraction rule}.
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{\displaystyle f\oftype\prod_{x\oftype A}B}}%
                    \infer1[(ev1)]{\context{\Gamma,\,x\oftype A}{f(x)\oftype B(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{the-pi-formation-rule-congruence-rule-for-pi-elimination}\SloganFont{Congruence Rule for Π-Elimination. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Slogan: }Judgementall equal dependent functions evaluate to judgemental equal terms.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{\displaystyle f\doteq f'\oftype\prod_{x\oftype A}B}}%
                    \infer1[(ev-eq)]{\context{\Gamma,\,x\oftype A}{f(x)\doteq f'(x)\oftype B(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{definition}
\begin{definition}{The Π-Computations Rules}{the-pi-computation-rules}%
    Martin-Löf type theory has the following inference rules about computation of Π-types:\index[type-theory]{Π-computation rules}%
    \begin{enumerate}
        \item\label{the-pi-computation-rules-beta-reduction}\SloganFont{β-Reduction. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Slogan: }β-reduction is inverse to λ-abstraction.
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A}{b(x)\oftype B(x)}}%
                    \infer1[(β)]{\context{\Gamma,\,x\oftype A}{\llbracket y\mapsto b(y)\rrbracket(x)\doteq b(x)\oftype B(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{the-pi-computation-rules-eta-conversion}\SloganFont{η-Conversion. }We have%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Slogan: }All terms of a Π-type are dependent functions.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{\displaystyle f\oftype\prod_{x\oftype A}B(x)}}%
                    \infer1[(η)]{\context{\Gamma}{\displaystyle\llbracket x\mapsto f(x)\rrbracket\doteq f\oftype\prod_{x\oftype A}B(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{definition}
\begin{proposition}{Properties of Dependent Function Types}{properties-of-dependent-function-types}%
    Let $A$ be a type and let $B(x)$ be a type family indexed over $x\oftype A$.
    \begin{enumerate}
        \item\label{properties-of-dependent-function-types-dependent-function-extensionality}\SloganFont{Dependent Function Extensionality. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{\displaystyle f\oftype\prod_{x\oftype A}B(x)}}%
                    \hypo{\context{\Gamma}{\displaystyle f'\oftype\prod_{x\oftype A}B(x)}}%
                    \hypo{\context{\Gamma,x\oftype A}{f(x)\doteq f'(x)\oftype B(x)}}%
                    \infer3[(FEXT)]{\context{\Gamma}{\displaystyle f\doteq f'\oftype\prod_{x\oftype A}B(x)}}%
                \end{prooftree}%
            \end{webprooftree}%
        \item\label{properties-of-function-types-changing-the-order-of-arguments}\SloganFont{Changing the Order of Arguments. }Let $A$ and $B$ be types and let $C$ be a type family indexed over $x\oftype A$ and $y\oftype B$.
            \begin{enumerate}
                \item\label{properties-of-function-types-changing-the-order-of-arguments-1}We have a \textbf{swap function}
                    \[
                        \sigma%
                        \oftype%
                        \left(\prod_{x\oftype A}\prod_{y\oftype B}C(x,y)\right)%
                        \to%
                        \left(\prod_{y\oftype B}\prod_{x\oftype A}C(x,y)\right)%
                    \]%
                    defined by the swap rule
                    \begin{scalewebprooftree}%
                        \begin{prooftree}%
                            \hypo{\context{\Gamma}{A\type}}%
                            \hypo{\context{\Gamma}{B\type}}%
                            \hypo{\context{\Gamma,\,x\oftype A,\,y\oftype B}{C(x,y)\type}}%
                            \infer3[(swap)]{\context{\Gamma}{\displaystyle\sigma\oftype\left(\prod_{x\oftype A}\prod_{y\oftype B}C(x,y)\right)\to\left(\prod_{y\oftype B}\prod_{x\oftype A}C(x,y)\right)}}%
                        \end{prooftree}%
                        .%
                    \end{scalewebprooftree}%
                \item\label{properties-of-function-types-changing-the-order-of-arguments-1}We have
                    \begin{scalewebprooftree}%
                        \begin{prooftree}%
                            \hypo{\context{\Gamma}{A\type}}%
                            \hypo{\context{\Gamma}{B\type}}%
                            \hypo{%
                                \context{%
                                    \Gamma,\,%
                                    x\oftype A,\,%
                                    y\oftype A%
                                }{%
                                    C(x,y)\type%
                            }}%
                            \infer3{%
                                \context{%
                                    \Gamma%
                                }{%
                                    \displaystyle%
                                    \sigma\circ\sigma%
                                    \doteq%
                                    \sfid_{\scriptdisplaystyle{\prod_{x\oftype A}\prod_{y\oftype B}C(x,y)}}%
                                    \oftype%
                                    \left(\prod_{x\oftype A}\prod_{y\oftype B}C(x,y)\right)%
                                    \to%
                                    \left(\prod_{x\oftype A}\prod_{y\oftype B}C(x,y)\right)%
                            }}%
                        \end{prooftree}%
                        .%
                    \end{scalewebprooftree}%
            \end{enumerate}
        %\item\label{properties-of-function-types-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-dependent-function-types}}%
    \FirstProofBox{\cref{properties-of-dependent-function-types-dependent-function-extensionality}: Dependent Function Extensionality}%
    We have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{\displaystyle f\oftype\prod_{x\oftype A}B(x)}}%
            \infer1[(η)]{\context{\Gamma}{\displaystyle\llbracket x\mapsto f(x)\rrbracket\doteq f\oftype\prod_{x\oftype A}B(x)}}%
            \hypo{\context{\Gamma,a\oftype A}{f(a)\doteq f'(a)\oftype B}}%
            \infer1[(λ-eq)]{\context{\Gamma}{\displaystyle\llbracket x\mapsto f(x)\rrbracket\doteq\llbracket x\mapsto f'(x)\rrbracket\oftype\prod_{x\oftype A}B(x)}}%
            \infer2[(trans)]{\context{\Gamma}{\displaystyle f\doteq\llbracket x\mapsto f'(x)\rrbracket\oftype\prod_{x\oftype A}B(x)}}%
            \hypo{\context{\Gamma}{\displaystyle f'\oftype\prod_{x\oftype A}B(x)}}%
            \infer1[(η)]{\context{\Gamma}{\displaystyle\llbracket x\mapsto f'(x)\rrbracket\doteq f'\oftype\prod_{x\oftype A}B(x)}}%
            \infer2[(trans)]{\context{\Gamma}{\displaystyle f\doteq f'\oftype\prod_{x\oftype A}B(x)}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the proof.

    \ProofBox{\cref{properties-of-function-types-changing-the-order-of-arguments}: Changing the Order of Arguments}%
    Omitted.
\end{Proof}
\subsection{Function Types and Functions}\label{subsection-martin-löf-type-theory-function-types-and-functions}
Let $A$ and $B$ be types.
\begin{definition}{Function Types}{function-types}%
    The \index[type-theory]{function type}\textbf{type of (ordinary) functions from $A$ to $B$} is the type%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Notation: }Also written \index[notation]{BA@$B^{A}$}$B^{A}$ or \index[notation]{AB@$[A,B]$}$[A,B]$.
    } %
    %---  End Footnote  ---%
    \index[notation]{AtoB@$A\to B$}$A\to B$ defined by%
    \[
        A\to B%
        \defeq%
        \prod_{x\oftype A}B%
    \]%
    via the derivation
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \infer2[(W)]{\context{\Gamma,\,x\oftype A}{B\type}}
            \infer1[(Π)]{\context{\Gamma}{\displaystyle\prod_{x\oftype A}B}}
            \infer1[(Π)]{\context{\Gamma}{\displaystyle A\to B\doteq\prod_{x\oftype A}B\type}}
        \end{prooftree}%
        .%
    \end{webprooftree}%
\end{definition}
\begin{definition}{Further Terminology for Function Types}{further-terminology-for-function-types}%
    Let $A\to B$ be the type of functions from $A$ to $B$.
    \begin{enumerate}
        \item\label{further-terminology-for-function-types-functions}The terms of $A\to B$ are called \index[type-theory]{function}\textbf{functions}.
        \item\label{further-terminology-for-function-types-domain}Given a function $f\oftype A\to B$, the type $A$ is called its \index[type-theory]{domain}\textbf{domain}.
        \item\label{further-terminology-for-function-types-codomain}Given a function $f\oftype A\to B$, the type $B$ is called its \index[type-theory]{codomain}\textbf{codomain}.
    \end{enumerate}
\end{definition}
\begin{example}{Identity Functions}{identity-functions-example}%
    See \cref{subsection-martin-löf-type-theory-identity-functions}.
\end{example}
\begin{example}{Constant Functions}{constant-functions}%
    Given a term $y$ of type $B$, we have a function \index[notation]{consty@$\const_{y}$}$\const_{y}\oftype A\to B$, giving rise to a judgement of the form
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \infer2{\context{\Gamma,\,y\oftype B}{\const_{y}\oftype A\to B}}%
        \end{prooftree}%
        ,%
    \end{webprooftree}%
    and being defined by
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \hypo{\context{\Gamma}{y\oftype B}}%
            \infer3[(const)]{\context{\Gamma}{\const_{y}\doteq\llbracket x\mapsto y\rrbracket\oftype A\to B}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    It satisfies the following two properties:
    \begin{enumerate}
        \item\label{constant-functions-evaluation-for-constant-functions}\SloganFont{Evaluation for Constant Functions. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \hypo{\context{\Gamma}{y\oftype B}}%
                    \infer3[(const-ev)]{\context{\Gamma,\,x\oftype A}{\const_{y}(x)\doteq y\oftype B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{constant-functions-postcomposition-with-the-constant-function}\SloganFont{Postcomposition With the Constant Function. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{f\oftype A\to B}}%
                    \hypo{\context{\Gamma}{C\type}}%
                    \infer2{\context{\Gamma,\,z\oftype C}{\const_{z}\circ f\doteq\const_{z}\oftype A\to C}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{constant-functions-precomposition-with-the-constant-function}\SloganFont{Precomposition With the Constant Function. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{g\oftype B\to C}}%
                    \infer2{\context{\Gamma,\,y\oftype B}{g\circ\const_{y}\doteq\const_{g(y)}\oftype A\to C}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{example}
\begin{Proof}{Proof of \cref{constant-functions}}%
    \FirstProofBox{Construction of $\const$}%
    We have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \infer1[(G)]{\context{\Gamma,\,y\oftype B}{y\oftype B}}%
            \infer2[(const)]{\context{\Gamma,\,y\oftype B}{\const_{y}\oftype A\to B}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    This finishes the construction of $\const_{y}$.

    \ProofBox{\cref{constant-functions-evaluation-for-constant-functions}: Evaluation for Constant Functions}%
    We have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \hypo{\context{\Gamma}{y\oftype B}}%
            \infer3[(const-def)]{\context{\Gamma}{\const_{y}\doteq\llbracket x\mapsto y\rrbracket\oftype A\to B}}%
            \infer1[(ev-eq)]{\context{\Gamma,\,a\oftype A}{\const_{y}(a)\doteq\llbracket x\mapsto y\rrbracket(a)\oftype A}}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{A\type}}%
            \infer1[(G)]{\context{\Gamma,\,a\oftype A}{a\oftype A}}%
            \infer2[(β)]{\context{\Gamma,\,a\oftype A}{\llbracket x\mapsto y\rrbracket(a)\doteq a\oftype A}}%
            \infer2[(trans)]{\context{\Gamma,\,a\oftype A}{\const_{y}(a)\doteq a\oftype A}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the proof.%


    \ProofBox{\cref{constant-functions-postcomposition-with-the-constant-function}: Postcomposition With the Constant Function}%
    Firstly, note that it suffices to produce a derivation for the judgement $\context{\Gamma,\,x\oftype A}{\const_{y}(f(x))\doteq y\oftype B}$, as we can then finish that derivation with
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\evdots}%
            \infer1{\context{\Gamma,\,x\oftype A}{\const_{y}(f(x))\doteq y\oftype B}}
            \infer1[(λ-eq)]{\context{\Gamma}{\llbracket x\mapsto\const_{y}(f(x))\rrbracket\doteq\llbracket x\mapsto y\rrbracket\oftype A\to B}}%
            \hypo{\context{\Gamma}{\const_{y}\oftype A\to B}}%
            \infer1[(η)]{\context{\Gamma}{\llbracket x\mapsto y\rrbracket\doteq\const_{y}\oftype A\to B}}%
            \infer2[(trans)]{\context{\Gamma}{\const_{y}\circ f\doteq\const_{y}\oftype A\to B}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    Now, for the proof of the judgement, we have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{f\oftype A\to B}}%
            \infer1[(ev1)]{\context{\Gamma,\,x\oftype A}{f(x)\oftype B}}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{C\type}}%
            \hypo{\context{\Gamma}{z\oftype C}}%
            \infer3[(const)]{\context{\Gamma}{\const_{z}\doteq\llbracket x\mapsto z\rrbracket\oftype A\to C}}%
            \infer1[(const-ev)]{\context{\Gamma,\,y\oftype B}{\const_{z}(y)\doteq z\oftype C}}%
            \infer1[(W)]{\context{\Gamma,\,x\oftype A,\,y\oftype B}{\const_{z}(y)\doteq z\oftype C}}%
            \infer2[(S)]{\context{\Gamma,\,x\oftype A}{\const_{z}(f(x))\doteq z\oftype B}}
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the proof.

    \ProofBox{\cref{constant-functions-precomposition-with-the-constant-function}: Precomposition With the Constant Function}%
    Firstly, note that it suffices to produce a derivation for the judgement $\context{\Gamma,\,x\oftype A}{g(\const_{y}(x))\doteq g(y)\oftype C}$, as we can then finish that derivation with
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\evdots}%
            \infer1{\context{\Gamma,\,x\oftype A}{g(\const_{y}(x))\doteq g(y)\oftype C}}
            \infer1[(λ-eq)]{\context{\Gamma}{\llbracket x\mapsto g(\const_{y}(x))\rrbracket\doteq\llbracket x\mapsto g(y)\rrbracket\oftype A\to C}}%
            \hypo{\context{\Gamma}{\const_{g(y)}\oftype A\to C}}%
            \infer1[(η)]{\context{\Gamma}{\llbracket x\mapsto g(y)\rrbracket\doteq\const_{g(y)}\oftype A\to C}}%
            \infer2[(trans)]{\context{\Gamma}{g\circ\const_{y}\doteq\const_{g(y)}\oftype A\to C}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    Now, for the proof of the judgement, we have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \hypo{\context{\Gamma}{y\oftype B}}%
            \infer3[(const-ev)]{\context{\Gamma,\,x\oftype A}{\const_{y}(x)\doteq y\oftype B}}%
            \hypo{\context{\Gamma}{g\oftype B\to C}}%
            \infer1[(refl)]{\context{\Gamma}{g\doteq g\oftype B\to C}}%
            \infer2[(ev-eq)]{\context{\Gamma,\,x\oftype A}{g(\const_{y}(x))\doteq g(y)\oftype C}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    This finishes the proof.
\end{Proof}
\begin{proposition}{Inference Rules for Function Types}{properties-of-function-types}%
    Let $A$ and $B$ be types.
    \begin{enumerate}
        \item\label{properties-of-function-types-formation-of-function-types}\SloganFont{Formation of Function Types. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \infer2[(FT)]{\context{\Gamma}{A\to B\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-function-types-congruence-rule-for-the-formation-of-function-types}\SloganFont{Congruence Rule for the Formation of Function Types. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\doteq A'\type}}%
                    \hypo{\context{\Gamma}{B\doteq B'\type}}%
                    \infer2[(Π-eq)]{\context{\Gamma}{(A\to B)\doteq(A'\to B')\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-function-types-lambda-abstraction}\SloganFont{λ-Abstraction. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \hypo{\context{\Gamma,\,x\oftype A}{b(x)\oftype B}}%
                    \infer2[(λ)]{\context{\Gamma}{\llbracket x\mapsto b(x)\rrbracket\oftype A\to B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-function-types-congruence-rule-for-the-formation-of-functions}\SloganFont{Congruence Rule for the Formation of Functions. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A}{b(x)\doteq b'(x)\oftype B}}%
                    \infer1[(λ-eq)]{\context{\Gamma}{\llbracket x\mapsto b(x)\rrbracket\doteq\llbracket x\mapsto b'(x)\rrbracket\oftype A\to B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-function-types-evaluation-1}\SloganFont{Evaluation \rmI. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{f\oftype A\to B}}%
                    \infer1[(ev1)]{\context{\Gamma,\,x\oftype A}{f(x)\oftype B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-function-types-evaluation-2}\SloganFont{Evaluation \rmII. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \hypo{\context{\Gamma}{f\oftype A\to B}}%
                    \infer2[(ev2)]{\context{\Gamma}{f(a)\oftype B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-function-types-evaluation-3}\SloganFont{Evaluation \rmIII. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \infer2[(ev3)]{\context{\Gamma,\,f\oftype A\to B,\,x\oftype A}{f(x)\oftype B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-function-types-congruence-rule-for-evaluation}\SloganFont{Congruence Rule for Evaluation. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{f\doteq f'\oftype A\to B}}%
                    \infer1[(ev-eq)]{\context{\Gamma,\,x\oftype A}{f(x)\doteq f'(x)\oftype B}}%
                \end{prooftree}%
            \end{webprooftree}%
        \item\label{properties-of-function-types-beta-reduction}\SloganFont{β-Reduction. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \hypo{\context{\Gamma,\,x\oftype A}{b(x)\oftype B}}%
                    \infer2[(β)]{\context{\Gamma,\,x\oftype A}{\llbracket y\mapsto b(y)\rrbracket(x)\doteq b(x)\oftype B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-function-types-eta-conversion}\SloganFont{η-Conversion. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{f\oftype A\to B}}%
                    \infer1[(η)]{\context{\Gamma}{\llbracket x\mapsto f(x)\rrbracket\doteq f\oftype A\to B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-function-types-function-extensionality}\SloganFont{Function Extensionality. }We have
            \begin{scalewebprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{f\oftype A\to B}}%
                    \hypo{\context{\Gamma}{f'\oftype A\to B}}%
                    \hypo{\context{\Gamma,a\oftype A}{f(a)\doteq f'(a)\oftype B}}%
                    \infer3[(FEXT)]{\context{\Gamma}{f\doteq f'\oftype A\to B}}%
                \end{prooftree}%
            \end{scalewebprooftree}%
        %\item\label{properties-of-function-types-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-function-types}}%
    \ProofBox{\cref{properties-of-function-types-formation-of-function-types}: Formation of Function Types}%
    This follows from the respective inference rule for dependent function types, \cref{the-pi-formation-rule}.

    \ProofBox{\cref{properties-of-function-types-congruence-rule-for-the-formation-of-function-types}: Congruence Rule for the Formation of Function Types}%
    This follows from the respective inference rule for dependent function types, \cref{the-pi-formation-rule-congruence-rule-for-the-formation-of-pi-types} of \cref{the-pi-formation-rule}.

    \ProofBox{\cref{properties-of-function-types-lambda-abstraction}: λ-Abstraction}%
    This follows from the respective inference rule for dependent function types, \cref{the-pi-introduction-rule}.

    \ProofBox{\cref{properties-of-function-types-congruence-rule-for-the-formation-of-functions}: Congruence Rule for the Formation of Functions}%
    This follows from the respective inference rule for dependent function types, \cref{the-pi-introduction-rule-congruence-rule-for-the-formation-of-terms-of-pi-types} of \cref{the-pi-formation-rule}.

    \ProofBox{\cref{properties-of-function-types-evaluation-1}: Evaluation \rmI}%
    This follows from the respective inference rule for dependent function types, \cref{the-pi-elimination-rule}.

    \ProofBox{\cref{properties-of-function-types-evaluation-2}: Evaluation \rmII}%
    We have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{a\oftype A}}%
            \hypo{\context{\Gamma}{f\oftype A\to B}}%
            \infer1[(ev1)]{\context{\Gamma,\,x\oftype A}{f(x)\oftype B}}%
            \infer2[(S)]{\context{\Gamma}{f[a/x]\oftype B[a/x]}}%
            \infer1{\context{\Gamma}{f(a)\oftype B}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    This finishes the proof.

    \ProofBox{\cref{properties-of-function-types-evaluation-3}: Evaluation \rmIII}%
    We have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \infer2[(FT)]{\context{\Gamma}{A\to B\type}}%
            \infer1[(G)]{\context{\Gamma,\,f\oftype A\to B}{f\oftype A\to B}}%
            \infer1[(ev1)]{\context{\Gamma,\,f\oftype A\to B,\,x\oftype A}{f(x)\oftype B}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    This finishes the proof.

    \ProofBox{\cref{properties-of-function-types-congruence-rule-for-evaluation}: Congruence Rule for Evaluation}%
    This follows from the respective inference rule for dependent function types, \cref{the-pi-formation-rule-congruence-rule-for-pi-elimination} of \cref{the-pi-formation-rule}.

    \ProofBox{\cref{properties-of-function-types-beta-reduction}: β-Reduction}%
    This follows from the respective inference rule for dependent function types, \cref{the-pi-computation-rules-beta-reduction} of \cref{the-pi-computation-rules}.

    \ProofBox{\cref{properties-of-function-types-eta-conversion}: η-Conversion}%
    This follows from the respective inference rule for dependent function types, \cref{the-pi-computation-rules-eta-conversion} of \cref{the-pi-computation-rules}.

    \ProofBox{\cref{properties-of-function-types-function-extensionality}: Function Extensionality}%
    This follows from the respective inference rule for dependent function types, \cref{properties-of-dependent-function-types-dependent-function-extensionality} of \cref{properties-of-dependent-function-types}. Here, however, is a complete derivation:
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{f\oftype A\to B}}%
            \infer1[(η)]{\context{\Gamma}{\llbracket x\mapsto f(x)\rrbracket\doteq f\oftype A\to B}}%
            \hypo{\context{\Gamma,a\oftype A}{f(a)\doteq f'(a)\oftype B}}%
            \infer1[(λ-eq)]{\context{\Gamma}{\llbracket x\mapsto f(x)\rrbracket\doteq\llbracket x\mapsto f'(x)\rrbracket\oftype A\to B}}%
            \infer2[(trans)]{\context{\Gamma}{f\doteq\llbracket x\mapsto f'(x)\rrbracket\oftype A\to B}}%
            \hypo{\context{\Gamma}{f'\oftype A\to B}}%
            \infer1[(η)]{\context{\Gamma}{\llbracket x\mapsto f'(x)\rrbracket\doteq f'\oftype A\to B}}%
            \infer2[(trans)]{\context{\Gamma}{f\doteq f'\oftype A\to B}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the proof.
\end{Proof}
\subsection{Identity Functions}\label{subsection-martin-löf-type-theory-identity-functions}
Let $A$ be a type.
\begin{definition}{Identity Functions}{identity-functions}%
    The \index[type-theory]{identity function}\textbf{identity function} of $A$ is the term \index[notation]{idA@$\sfid_{A}$}$\sfid_{A}\oftype A\to A$ defined by
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \infer1[(id-def)]{\context{\Gamma}{\sfid_{A}\doteq\llbracket x\mapsto x\rrbracket\oftype A\to A}}%
        \end{prooftree}%
    \end{webprooftree}%
    via the derivation
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{A\type}}%
            \infer1[(G)]{\context{\Gamma,\,x\oftype A}{x\oftype A}}%
            \infer2[(λ)]{\context{\Gamma}{\llbracket x\mapsto x\rrbracket\oftype A\to A}}%
            \infer1{\context{\Gamma}{\sfid_{A}\doteq\llbracket x\mapsto x\rrbracket\oftype A\to A}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
\end{definition}
\begin{proposition}{Inference Rules for Identity Functions}{inference-rules-for-identity-functions}%
    Let $A$ be a type.
    \begin{enumerate}
        \item\label{inference-rules-for-identity-functions-formation-of-identity-functions}\SloganFont{Formation of Identity Functions. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \infer1[(id)]{\context{\Gamma}{\sfid_{A}\oftype A\to A}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{inference-rules-for-identity-functions-evaluation-for-identity-functions}\SloganFont{Evaluation for Identity Functions. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \infer1[(id-ev)]{\context{\Gamma,\,x\oftype A}{\sfid_{A}(x)\doteq x\oftype A}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        %\item\label{inference-rules-for-identity-functions-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{inference-rules-for-identity-functions}}%
    \FirstProofBox{\cref{inference-rules-for-identity-functions-formation-of-identity-functions}: Formation of Identity Functions}%
    This follows from \cref{formation-of-contexts-types-and-terms-in-martin-löf-type-theory-formation-of-judgemental-equality-of-terms-1} of \cref{formation-of-contexts-types-and-terms-in-martin-löf-type-theory}.

    \ProofBox{\cref{inference-rules-for-identity-functions-evaluation-for-identity-functions}: Evaluation for Identity Functions}%
    We have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \infer1[(id-def)]{\context{\Gamma}{\sfid_{A}\doteq\llbracket x\mapsto x\rrbracket\oftype A\to A}}%
            \infer1[(ev-eq)]{\context{\Gamma,\,a\oftype A}{\sfid_{A}(a)\doteq\llbracket x\mapsto x\rrbracket(a)\oftype A}}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{A\type}}%
            \infer1[(G)]{\context{\Gamma,\,a\oftype A}{a\oftype A}}%
            \infer2[(β)]{\context{\Gamma,\,a\oftype A}{\llbracket x\mapsto x\rrbracket(a)\doteq a\oftype A}}%
            \infer2[(trans)]{\context{\Gamma,\,a\oftype A}{\sfid_{A}(a)\doteq a\oftype A}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the proof.
\end{Proof}
\subsection{Composition of Functions}\label{subsection-martin-löf-type-theory-composition-of-functions}
Let $A$, $B$, and $C$ be types.
\begin{definition}{Composition of Functions}{composition-of-functions}%
    The \index[type-theory]{composition operation}\textbf{composition operation} associated to $A$, $B$, and $C$ is the term%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Notation: }We write $g\circ f$ for $\comp(g)(f)$.
        \par\vspace*{\TCBBoxCorrection}
    }%
    %---  End Footnote  ---%
    \[
        \comp_{A,B,C}%
        \oftype%
        [B,C]%
        \to%
        [[A,B],[A,C]]
    \]%
    of type $[B,C]\to[[A,B],[A,C]]$ defined by
    \begin{align*}
        \comp_{A,B,C} &\defeq \lambda g\ldotp\lambda f\ldotp \lambda x\ldotp g(f(x))\\
                      &\defeq \llbracket g\mapsto\llbracket f\mapsto\llbracket x\mapsto g(f(x))\rrbracket\rrbracket\rrbracket
    \end{align*}
    via the derivation
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \infer2[(ev3)]{\context{\Gamma,\,f\oftype[A,B],\,x\oftype A}{f(x)\oftype B}}%
            \infer1[(W)]{\context{\Gamma,\,g\oftype[B,C],\,f\oftype[A,B],\,x\oftype A}{f(x)\oftype B}}%
            \hypo{\context{\Gamma}{B\type}}%
            \hypo{\context{\Gamma}{C\type}}%
            \infer2[(ev3)]{\context{\Gamma,\,g\oftype[B,C],\,y\oftype B}{g(y)\oftype C}}%
            \infer1[(W)]{\context{\Gamma,\,g\oftype[B,C],\,f\oftype[A,B],\,y\oftype B}{g(y)\oftype C}}%
            \infer2[(ev1)]{\context{\Gamma,\,g\oftype[B,C],\,f\oftype[A,B],\,x\oftype A}{g(f(x))\oftype C}}%
            \infer1[(λ)]{\context{\Gamma,\,g\oftype[B,C],\,f\oftype[A,B]}{\llbracket x\mapsto g(f(x))\rrbracket\oftype[A,C]}}%
            \infer1[(λ)]{\context{\Gamma,\,g\oftype[B,C]}{\llbracket f\mapsto\llbracket x\mapsto g(f(x))\rrbracket\rrbracket\oftype[[A,B],[A,C]]}}%
            \infer1[(λ)]{\context{\Gamma}{\llbracket g\mapsto\llbracket f\mapsto\llbracket x\mapsto g(f(x))\rrbracket\rrbracket\rrbracket\oftype[[B,C],[[A,B],[A,C]]]}}%
            \infer1{\context{\Gamma}{\comp_{A,B,C}\doteq\llbracket g\mapsto\llbracket f\mapsto\llbracket x\mapsto g(f(x))\rrbracket\rrbracket\rrbracket\oftype[B,C]\to[[A,B],[A,C]]}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
\end{definition}
\begin{proposition}{Properties of Composition of Functions}{properties-of-composition-of-functions}%
    Let $A$, $B$, and $C$ be types.
    \begin{enumerate}
        \item\label{properties-of-composition-of-functions-forming-composition}\SloganFont{Forming Composition. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{f\oftype A\to B}}%
                    \hypo{\context{\Gamma}{g\oftype B\to C}}%
                    \infer2[(comp)]{\context{\Gamma}{g\circ f\oftype A\to C}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-composition-of-functions-associativity}\SloganFont{Associativity. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{f\oftype A\to B}}%
                    \hypo{\context{\Gamma}{g\oftype B\to C}}%
                    \hypo{\context{\Gamma}{h\oftype C\to D}}%
                    \infer3[(ass)]{\context{\Gamma}{(h\circ g)\circ f\doteq h\circ(g\circ f)\oftype A\to D}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-composition-of-functions-left-unitality}\SloganFont{Left Unitality. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{f\oftype A\to B}}%
                    \infer1[(LU)]{\context{\Gamma}{\sfid_{B}\circ f\doteq f\oftype A\to B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-composition-of-functions-right-unitality}\SloganFont{Right Unitality. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{f\oftype A\to B}}%
                    \infer1[(RU)]{\context{\Gamma}{f\circ\sfid_{A}\doteq f\oftype A\to B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        %\item\label{properties-of-composition-of-functions-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-composition-of-functions}}%
    \FirstProofBox{\cref{properties-of-composition-of-functions-forming-composition}: Forming Composition}%
    This follows from the definition of $g\circ f\defeq\comp(g)(f)$.

    \ProofBox{\cref{properties-of-composition-of-functions-associativity}: Associativity}%
    Firstly, note that we have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{f\oftype A\to B}}%
            \hypo{\context{\Gamma}{g\oftype B\to C}}%
            \hypo{\context{\Gamma}{h\oftype C\to D}}%
            \infer2[(comp)]{\context{\Gamma}{h\circ g\oftype B\to D}}%
            \infer2[(comp)]{\context{\Gamma}{(h\circ g)\circ f\oftype A\to D}}%
        \end{prooftree}%
    \end{webprooftree}%
    and
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{f\oftype A\to B}}%
            \hypo{\context{\Gamma}{g\oftype B\to C}}%
            \infer2[(comp)]{\context{\Gamma}{g\circ f\oftype A\to C}}%
            \hypo{\context{\Gamma}{h\oftype C\to D}}%
            \infer2[(comp)]{\context{\Gamma}{h\circ(g\circ f)\oftype A\to D}}%
        \end{prooftree}%
        ,%
    \end{webprooftree}%
    so taking the judgement $\context{\Gamma,\,x\oftype A}{h(g(f(x)))\doteq h(g(f(x)))\oftype D}$ for granted for now, we have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{(h\circ g)\circ f\oftype A\to D}}%
            \hypo{\context{\Gamma}{h\circ(g\circ f)\oftype A\to D}}%
            \hypo{\context{\Gamma,\,x\oftype A}{h(g(f(x)))\doteq h(g(f(x)))\oftype D}}%
            \hypo{\context{\Gamma,\,x\oftype A}{(h\circ g)(f(x))\doteq h(g(f(x)))\oftype D}}%
            \infer2[(trans)]{\context{\Gamma,\,x\oftype A}{(h\circ g)(f(x))\doteq h(g(f(x)))\oftype D}}
            \hypo{\context{\Gamma,\,x\oftype A}{((h\circ g)\circ f)(x)\doteq(h\circ g)(f(x))\oftype D}}%
            \infer2[(trans)]{\context{\Gamma,\,x\oftype A}{((h\circ g)\circ f)(x)\doteq h(g(f(x)))\oftype D}}
            \hypo{\context{\Gamma,\,x\oftype A}{h(g(f(x)))\doteq h((g\circ f)(x))\oftype D}}%
            \hypo{\context{\Gamma,\,x\oftype A}{h((g\circ f)(x))\doteq(h\circ(g\circ f)(x))\oftype D}}%
            \infer2[(trans)]{\context{\Gamma,\,x\oftype A}{h(g(f(x)))\doteq(h\circ(g\circ f)(x))\oftype D}}
            \infer2[(trans)]{\context{\Gamma,\,x\oftype A}{((h\circ g)\circ f)(x)\doteq(h\circ(g\circ f)(x))\oftype D}}
            \infer3[(FEXT)]{\context{\Gamma}{(h\circ g)\circ f\doteq h\circ(g\circ f)\oftype A\to D}}
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    Thus, to prove $(h\circ g)\circ f\doteq h\circ(g\circ f)$, it remains to show $\context{\Gamma,\,x\oftype A}{h(g(f(x)))\doteq h(g(f(x)))\oftype D}$. For this, we have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{f\oftype A\to B}}%
            \infer1[(ev1)]{\context{\Gamma,\,x\oftype A}{f(x)\oftype B}}%
            \hypo{\context{\Gamma}{g\oftype B\to C}}%
            \infer1[(ev1)]{\context{\Gamma,\,y\oftype B}{g(y)\oftype C}}%
            \infer1[(W)]{\context{\Gamma,\,x\oftype A,\,y\oftype B}{g(y)\oftype C}}%
            \infer2[(S)]{\context{\Gamma,\,x\oftype A}{g(f(x))\oftype C}}%
            \hypo{\context{\Gamma}{h\oftype C\to D}}%
            \infer1[(ev1)]{\context{\Gamma,\,z\oftype C}{h(z)\oftype D}}%
            \infer1[(W)]{\context{\Gamma,\,x\oftype A,\,z\oftype C}{h(z)\oftype D}}%
            \infer2[(S)]{\context{\Gamma,\,x\oftype A}{h(g(f(x)))\oftype D}}%
            \infer1[(refl)]{\context{\Gamma,\,x\oftype A}{h(g(f(x)))\doteq h(g(f(x)))\oftype D}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the proof.

    \ProofBox{\cref{properties-of-composition-of-functions-left-unitality}: Left Unitality}%
    Firstly, note that it suffices to produce a derivation for the judgement $\context{\Gamma,\,x\oftype A}{\sfid_{B}(f(x))\doteq f(x)\oftype B}$, as we can then finish that derivation with
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\evdots}%
            \infer1{\context{\Gamma,\,x\oftype A}{\sfid_{B}(f(x))\doteq f(x)\oftype B}}
            \infer1[(λ-eq)]{\context{\Gamma}{\llbracket x\mapsto\sfid_{B}(f(x))\rrbracket\doteq\llbracket x\mapsto f(x)\rrbracket\oftype A\to B}}%
            \hypo{\context{\Gamma}{f\oftype A\to B}}%
            \infer1[(η)]{\context{\Gamma}{\llbracket x\mapsto f(x)\rrbracket\doteq f\oftype A\to B}}%
            \infer2[(trans)]{\context{\Gamma}{\sfid_{B}\circ f\doteq f\oftype A\to B}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    Now, for the proof of the judgement, we have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{f\oftype A\to B}}%
            \infer1[(ev1)]{\context{\Gamma,\,x\oftype A}{f(x)\oftype B}}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \infer1[(id-ev)]{\context{\Gamma,\,y\oftype B}{\sfid_{B}(y)\doteq y\oftype B}}%
            \infer2[(W)]{\context{\Gamma,\,x\oftype A,\,y\oftype B}{\sfid_{B}(y)\doteq y\oftype B}}
            \infer2[(S)]{\context{\Gamma,\,x\oftype A}{\sfid_{B}(f(x))\doteq f(x)\oftype B}}
        \end{prooftree}%
        .%
    \end{webprooftree}%
    This finishes the proof.

    \ProofBox{\cref{properties-of-composition-of-functions-right-unitality}: Right Unitality}%
    Firstly, note that it suffices to produce a derivation for the judgement $\context{\Gamma,\,x\oftype A}{f(\sfid_{A}(x))\doteq f(x)\oftype B}$, as we can then finish that derivation with
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\evdots}%
            \infer1{\context{\Gamma,\,x\oftype A}{f(\sfid_{A}(x))\doteq f(x)\oftype B}}
            \infer1[(λ-eq)]{\context{\Gamma}{\llbracket x\mapsto f(\sfid_{A}(x))\rrbracket\doteq\llbracket x\mapsto f(x)\rrbracket\oftype A\to B}}%
            \hypo{\context{\Gamma}{f\oftype A\to B}}%
            \infer1[(η)]{\context{\Gamma}{\llbracket x\mapsto f(x)\rrbracket\doteq f\oftype A\to B}}%
            \infer2[(trans)]{\context{\Gamma}{\sfid_{B}\circ f\doteq f\oftype A\to B}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    Now, for the proof of the judgement, we have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \infer1[(id-ev)]{\context{\Gamma,\,x\oftype A}{\sfid_{A}(x)\doteq x\oftype A}}%
            \hypo{\context{\Gamma}{f\oftype A\to B}}%
            \infer1[(refl)]{\context{\Gamma}{f\doteq f\oftype A\to B}}%
            \infer2[(ev-eq)]{\context{\Gamma,\,x\oftype A}{f(\sfid_{A}(x))\doteq f(x)\oftype B}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    This finishes the proof.
\end{Proof}
\section{The Natural Numbers}\label{subsection-martin-löf-type-theory-the-natural-numbers}
\subsection{Foundations}\label{subsection-martin-löf-type-theory-the-natural-numbers-foundations}
\begin{definition}{The $\N$-Formation Rule}{the-n-formation-rule}%
    Martin-Löf type theory has the following inference rule about the formation of the \index[type-theory]{natural numbers}\textbf{type of natural numbers}:\index[type-theory]{N-formation rule@$\N$-formation rule}%
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{}
            \infer1[($\N$-form)]{\vdash\N\type}
        \end{prooftree}%
        .%
    \end{webprooftree}%
\end{definition}
\begin{definition}{The Introduction Rules of $\N$}{the-introduction-rules-of-n}%
    Martin-Löf type theory has the following \index[type-theory]{natural numbers!introduction rules}\textbf{introduction rules} about the type of the natural numbers:%
    \begin{enumerate}
        \item\label{the-introduction-rules-of-n-the-zero-element}\SloganFont{The Zero Element. }We have\index[notation]{ZeroN@$0_{\N}$}%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{}%
                    \infer1[($\N$-zero)]{\vdash0_{\N}\oftype\N}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{the-introduction-rules-of-n-the-successor-function}\SloganFont{The Successor Function. }We have\index[notation]{succN@$\succ_{\N}$}%
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{}%
                    \infer1[($\N$-succ)]{\vdash\succ_{\N}\oftype\N\to\N}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{definition}
\begin{definition}{The Induction Principle of $\N$}{the-induction-principle-of-n}%
    Martin-Löf type theory has the following interderivable \index[type-theory]{induction principle of N@induction principle of $\N$}\index[type-theory]{natural numbers!induction principle}\textbf{induction principle} rules about the type of the natural numbers:\index[notation]{indN@$\ind_{\N}$}%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology: }The term $p_{0}\oftype P(0_{\N})$ is called the \index[type-theory]{induction principle of N@induction principle of $\N$!base case}\textbf{base case}.
    }%
    %---  End Footnote  ---%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology: }The term $p_{S}\oftype\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))$ is called the \index[type-theory]{induction principle of N@induction principle of $\N$!inductive step}\textbf{inductive step}.
        \par\vspace*{\TCBBoxCorrection}
    }%
    %---  End Footnote  ---%
    \begin{enumerate}
        \item\label{the-induction-principle-of-n-1}\SloganFont{The Induction Principle of $\N$, \rmI. }We have
            \begin{scalewebprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,n\oftype\N}{P(n)\type}}%
                    \hypo{\context{\Gamma}{p_{0}\oftype P(0_{\N})}}%
                    \hypo{\context{\Gamma}{\displaystyle p_{S}\oftype\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))}}%
                    \infer3[($\N$-ind1)]{\context{\Gamma}{\displaystyle\ind_{\N}(p_{0},p_{S})\oftype\prod_{n\oftype\N}P(n)}}%
                \end{prooftree}%
                .%
            \end{scalewebprooftree}%
        \item\label{the-induction-principle-of-n-2}\SloganFont{The Induction Principle of $\N$, \rmII. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,n\oftype\N}{P(n)\type}}%
                    \infer1[($\N$-ind2)]{\context{\Gamma}{\displaystyle\ind_{\N}\oftype P(0_{\N})\to\left[\left[\prod_{n\oftype\N}P(n),P(\succ_{\N}(n))\right],\prod_{n\oftype\N}P(n)\right]}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{definition}
\begin{Proof}{Proof of the Interderivability of \cref{the-induction-principle-of-n-1,the-induction-principle-of-n-2}}%
    \FirstProofBox{\cref{the-induction-principle-of-n-1}$\implies$\cref{the-induction-principle-of-n-2}}%
    First, let's derive $\context{\Gamma,\,p_{0}\oftype P(0_{\N})}{p_{0}\oftype P(0_{\N})}$ from $\context{\Gamma,\,n\oftype\N}{P(n)\type}$:
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,n\oftype\N}{P(n)\type}}%
            \hypo{}%
            \infer1[($\N$-zero)]{\vdash0_{\N}\oftype\N}%
            \infer2[(S)]{\context{\Gamma}{P(0_{\N})\type}}%
            \infer1[(G)]{\context{\Gamma,\,p_{0}\oftype P(0_{\N})}{p_{0}\oftype P(0_{\N})}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    Next, we derive
    \[
        \context{\Gamma,\,p_{S}\oftype\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))}{p_{S}\oftype\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))}
    \]%
    from $\context{\Gamma,\,n\oftype\N}{P(n)\type}$:
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,n\oftype\N}{P(n)\type}}%
            \hypo{}%
            \infer1[($\N$-succ)]{\vdash\succ_{\N}\oftype\N\to\N}%
            \hypo{}%
            \infer1[($\N$-form)]{\vdash\N\type}%
            \infer1[(G)]{\context{\Gamma,\,n\oftype\N}{n\oftype\N}}%
            \infer2[(ev2)]{\context{\Gamma,\,n\oftype\N}{\succ_{\N}(n)\oftype\N}}%
            \hypo{\context{\Gamma,\,n\oftype\N}{P(n)\type}}%
            \infer2[(S)]{\context{\Gamma,\,n\oftype\N}{P(\succ_{\N}(n))\type}}%
            \infer2[(FT)]{\context{\Gamma,\,n\oftype\N}{P(n)\to P(\succ_{\N}(n))\type}}%
            \infer1[(Π)]{\context{\Gamma}{\displaystyle\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))\type}}%
            \infer1[(G)]{\context{\Gamma,\,p_{S}\oftype\displaystyle\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))\type}{p_{S}\oftype\displaystyle\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    We then have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,n\oftype\N}{P(n)\type}}%
            \hypo{\context{\Gamma,\,p_{0}\oftype P(0_{\N})}{p_{0}\oftype P(0_{\N})}}%
            \hypo{\context{\Gamma,\,p_{S}\oftype\displaystyle\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))\type}{p_{S}\oftype\displaystyle\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))}}%
            \infer3[(WWW)]{\context{\Gamma,\,n\oftype\N,\,p_{0}\oftype P(0_{\N}),\,p_{S}\oftype\displaystyle\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))}{p_{S}\oftype\displaystyle\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))}}
            \infer1[($\N$-ind1)]{\context{\Gamma,\,p_{0}\oftype P(0_{\N}),\,p_{S}\oftype\displaystyle\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))}{\displaystyle\ind_{\N}(p_{0},p_{S})\oftype\prod_{n\oftype\N}P(n)\type}}%
            \infer1[(λ)]{\context{\Gamma,\,p_{0}\oftype P(0_{\N})}{\displaystyle\llbracket p_{S}\mapsto\ind_{\N}(p_{0},p_{S})\rrbracket\oftype\left[\prod_{n\oftype\N}P(n),\prod_{n\oftype\N}P(\succ_{\N}(n))\right]\to\prod_{n\oftype\N}P(n)}}%
            \infer1[(λ)]{\context{\Gamma}{\displaystyle\llbracket p_{0}\mapsto\llbracket p_{S}\mapsto\ind_{\N}(p_{0},p_{S})\rrbracket\rrbracket\oftype P(0_{\N})\to\left[\left[\prod_{n\oftype\N}\left[P(n),P(\succ_{\N}(n))\right]\right],\prod_{n\oftype\N}P(n)\right]}}%
        \end{prooftree}%
        ,%
    \end{scalewebprooftree}%
    where in (WWW) we applied weakening repeatedly for all hypotheses. This finishes the proof.

    \ProofBox{\cref{the-induction-principle-of-n-2}$\implies$\cref{the-induction-principle-of-n-1}}%
    We have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{p_{0}\oftype P(0_{\N})}}%
            \hypo{\context{\Gamma,\,n\oftype\N}{P(n)\type}}%
            \infer1[($\N$-ind2)]{\context{\Gamma}{\displaystyle\ind_{\N}\oftype P(0_{\N})\to\left(\left(\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))\right)\to\prod_{n\oftype\N}P(n)\right)}}%
            \infer2[(ev2)]{\context{\Gamma}{\displaystyle\ind_{\N}(p_{0})\oftype\left(\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))\right)\to\prod_{n\oftype\N}P(n)}}%
            \hypo{\context{\Gamma}{\displaystyle p_{S}\oftype\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))}}%
            \infer2[(ev2)]{\context{\Gamma}{\displaystyle\ind_{\N}(p_{0},p_{s})\oftype\prod_{n\oftype\N}P(n)}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the proof.
\end{Proof}
\begin{definition}{The Computation Rules of $\N$}{the-computation-rules-of-n}%
    Martin-Löf type theory has the following \index[type-theory]{natural numbers!computation rules}\textbf{computation rules} about the type of the natural numbers, dictating that induction works as it should:%
    \begin{enumerate}
        \item\label{the-computation-rules-of-n-the-base-case}\SloganFont{The Base Case. }We have
            \begin{scalewebprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,n\oftype\N}{P(n)\type}}%
                    \hypo{\context{\Gamma}{p_{0}\oftype P(0_{\N})}}%
                    \hypo{\context{\Gamma}{\displaystyle p_{S}\oftype\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))}}%
                    \infer3[($\N$-comp1)]{\context{\Gamma}{\displaystyle\ind_{\N}(p_{0},p_{S},0_{\N})\doteq p_{0}\oftype P(0_{\N})}}%
                \end{prooftree}%
                .%
            \end{scalewebprooftree}%
        \item\label{the-computation-rules-of-n-the-inductive-step}\SloganFont{The Inductive Step. }We have
            \begin{scalewebprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,n\oftype\N}{P(n)\type}}%
                    \hypo{\context{\Gamma}{p_{0}\oftype P(0_{\N})}}%
                    \hypo{\context{\Gamma}{\displaystyle p_{S}\oftype\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))}}%
                    \infer3[($\N$-comp2)]{\context{\Gamma,\,n\oftype\N}{\displaystyle\ind_{\N}(p_{0},p_{S},\succ_{\N}(n))\doteq p_{S}(n,\ind_{\N}(p_{0},p_{S},n))\oftype P(0_{\N})}}%
                \end{prooftree}%
                .%
            \end{scalewebprooftree}%
    \end{enumerate}
\end{definition}
\begin{proposition}{Properties of the Natural Numbers}{properties-of-the-natural-numbers}%
    Let $n\oftype\N$.
    \begin{enumerate}
        \item\label{properties-of-the-natural-numbers-successors-and-equality}\SloganFont{Successors and Equality. }The type
            \[
                (n\equals_{\N}m)%
                \biimplications%
                (\succ_{\N}(n)\equals_{\N}\succ_{\N}(m))%
            \]%
            is inhabited.%
            %--- Begin Footnote ---%
            \footnote{%
                This is Peano's seventh axiom in his work \cite{peano-book} describing what is now known as the \index[type-theory]{Peano axioms}\textbf{Peano axioms} for the natural numbers.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
        \item\label{properties-of-the-natural-numbers-zero-is-not-a-successor}\SloganFont{Zero Is Not a Successor. }For each $n\oftype\N$, the type
            \[
                0_{\N}%
                \nequals_{N}%
                \succ_{\N}(n)%
            \]%
            is inhabited.%
            %--- Begin Footnote ---%
            \footnote{%
                This is Peano's eighth axiom in \cite{peano-book}.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
        %\item\label{properties-of-the-natural-numbers-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-the-natural-numbers}}%
    \FirstProofBox{\cref{properties-of-the-natural-numbers-successors-and-equality}: Successors and Equality}%
    For the forward implication, we may use the action on paths of the successor function
    \[
        \ap_{\succ_{\N}}%
        \oftype%
        (n\equals_{\N}m)%
        \to%
        (\succ_{\N}(n)\equals_{\N}\succ_{\N}(m)).%
    \]%
    For the converse, we use \cref{properties-of-observational-equality-of-natural-numbers-relation-to-identity-types} of \cref{properties-of-observational-equality-of-natural-numbers}, constructing the backwards implication as the composition
    \[
        \begin{tikzcd}[row sep={0.0*\the\DL,between origins}, column sep={0.0*\the\DL,between origins}, background color=backgroundColor, ampersand replacement=\&]
            {(\succ_{\N}(n)\equals_{\N}\succ_{\N}(m))}
            \&[0.5\FourCm]
            \&[0.9\FourCm]
            \&[0.5\FourCm]
            {(\succ_{\N}(n)\equals_{\N}\succ_{\N}(m))\mrp{.}}
            \\[0.5\FourCm]
            \&[0.5\FourCm]
            {\sfEq_{\N}(\succ_{\N}(n),\succ_{\N}(m))}
            \&[0.9\FourCm]
            {\sfEq_{\N}(n,m)}
            \&[0.5\FourCm]
            % 1-Arrows
            \arrow[from=1-1,to=1-4,dashed]%
            %
            \arrow[from=1-1,to=2-2,"\dagger"',pos=0.325]%
            \arrow[from=2-2,to=2-3,"\sfid"']%
            \arrow[from=2-3,to=1-4,"\dagger"',pos=0.525]%
        \end{tikzcd}
    \]%
    where:
    \begin{itemize}
        \item The maps marked with $\dagger$ come from \cref{properties-of-observational-equality-of-natural-numbers-relation-to-identity-types} of \cref{properties-of-observational-equality-of-natural-numbers}.
        \item $\sfid$ is the identity function, as we have a judgemental equality $\sfEq_{\N}(\succ_{\N}(n),\succ_{\N}(m))\doteq\sfEq_{\N}(n,m)$.
    \end{itemize}
    This finishes the proof.

    \ProofBox{\cref{properties-of-the-natural-numbers-zero-is-not-a-successor}: Zero Is Not a Successor}%
    By \cref{properties-of-observational-equality-of-natural-numbers-relation-to-identity-types} of \cref{properties-of-observational-equality-of-natural-numbers}, we have a family of maps
    \[
        (0_{\N}\equals_{\N}\succ_{\N}(n))%
        \to
        \sfEq_{\N}(0_{\N},\succ_{\N}(n)).%
    \]%
    Since $\sfEq_{\N}(0_{\N},\succ_{\N}(n))\doteq\EmptyType$, we are done.
\end{Proof}
\subsection{Pattern Matching}\label{subsection-pattern-matching}
\begin{definition}{Pattern Matching}{pattern-matching}%
    A dependent function
    \[
        f%
        \oftype%
        \prod_{n\oftype\N}P(n)%
    \]%
    may be defined by \index[type-theory]{pattern matching}\textbf{pattern matching} by specifying
    \begin{align*}
        f(0_{\N})        &\defeq p_{0},\\
        f(\succ_{\N}(n)) &\defeq p_{S}(n,f(n)),%
    \end{align*}
    where:
    \begin{itemize}
        \item $p_{0}$ is a term of type $P(0_{\N})$.
        \item $p_{S}$ is a term of type $\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))$.
    \end{itemize}
\end{definition}
\begin{example}{Addition via Pattern Matching}{addition-via-pattern-matching}%
    We may define an addition operation $\add'_{\N}\oftype\N\to[\N,\N]$ via
    \begin{align*}
        \add'_{\N}(0_{\N},0_{\N})               &\defeq 0_{\N},\\%
        \add'_{\N}(0_{\N},\succ_{\N}(m))        &\defeq \succ_{\N}(m),\\%
        \add'_{\N}(\succ_{\N}(n),0_{\N})        &\defeq \succ_{\N}(n),\\%
        \add'_{\N}(\succ_{\N}(n),\succ_{\N}(m)) &\defeq \succ_{\N}(\succ_{\N}(\add'_{\N}(n,m))).%
    \end{align*}
\end{example}
\subsection{Observational Equality of Natural Numbers}\label{subsection-observational-equality-of-natural-numbers}
\begin{definition}{Observational Equality of Natural Numbers}{observational-equality-of-natural-numbers}%
    The \index[type-theory]{natural numbers!observational equality}\index[type-theory]{observational equality of natural numbers}\textbf{observational equality} of natural numbers is the function\index[notation]{EqN@$\sfEq_{\N}$}$\sfEq_{\N}\oftype\N\times\N\to\CatFont{U}_{0}$ satisfying the following conditions:
    \begin{enumerate}
        \item\label{observational-equality-of-natural-numbers-zero-is-observationally-equal-to-zero}\SloganFont{Zero Is Observationally Equal to Zero. }We have%$\sfEq_{\N}(0_{\N},0_{\N})\doteq\UnitType$.
            \[
                \sfEq_{\N}(0_{\N},0_{\N})%
                \doteq%
                \UnitType.%
            \]%
        \item\label{observational-equality-of-natural-numbers-zero-is-not-a-sucessor}\SloganFont{Zero Is Not a Successor. }We have%$\sfEq_{\N}(0_{\N},\succ_{\N}(n))\doteq\EmptyType$.
            \[
                \sfEq_{\N}(0_{\N},\succ_{\N}(n))%
                \doteq%
                \EmptyType.%
            \]%
        \item\label{observational-equality-of-natural-numbers-successor-is-not-zero}\SloganFont{Successor Is Not Zero. }We have%$\sfEq_{\N}(\succ_{\N}(n),0_{\N})\doteq\EmptyType$.
            \[
                \sfEq_{\N}(\succ_{\N}(n),0_{\N})%
                \doteq%
                \EmptyType.%
            \]%
        \item\label{observational-equality-of-natural-numbers-when-successors-are-observationally-equal}\SloganFont{When Successors Are Observationally Equal. }We have%$\sfEq_{\N}(\succ_{\N}(n),\succ_{\N}(m))\doteq\sfEq_{\N}(n,m)$.
            \[
                \sfEq_{\N}(\succ_{\N}(n),\succ_{\N}(m))%
                \doteq%
                \sfEq_{\N}(n,m).%
            \]%
    \end{enumerate}
\end{definition}
\begin{Proof}{Construction of $\sfEq_{\N}$}%
    We proceed by double induction on $n$ and $m$, first constructing terms
    \begin{gather*}
        E_{0} \oftype \N\to\CatFont{U}_{0},\\
        E_{S} \oftype \N\to((\N\to\CatFont{U}_{0})\to(\N\to\CatFont{U}_{0})).%
    \end{gather*}
    We define $E_{0}$ via induction, taking $E_{0}(0_{\N})\defeq\UnitType$ and $E_{0S}(n,X,m)\defeq\EmptyType$. Thus $E_{0}$ satisfies the judgemental equalities
    \begin{align*}
        E_{0}(0_{\N})     &\doteq \UnitType,\\%
        E_{0}(\succ_{\N}) &\doteq \EmptyType.%
    \end{align*}
    We also define $E_{S}$ via induction, taking $E_{S0}(0_{\N})\defeq\EmptyType$ and $E_{SS}(n,X,m)\doteq X(m)$. Thus $E_{S}$ satisfies the judgemental equalities
    \begin{align*}
        E_{S}(n,X,0_{\N})     &\doteq \EmptyType,\\%
        E_{S}(n,X,\succ_{\N}) &\doteq X(m).%
    \end{align*}
    The computation rules for induction then give
    \begin{align*}
        \sfEq_{\N}(0_{\N},m)        &\doteq E_{0}(m),\\%
        \sfEq_{\N}(\succ_{\N}(n),m) &\doteq E_{S}(n,\sfEq_{\N}(n),m).%
    \end{align*}
    This finishes the construction of $\sfEq_{\N}$.
\end{Proof}
\begin{proposition}{Properties of Observational Equality of Natural Numbers}{properties-of-observational-equality-of-natural-numbers}%
    Let $n\oftype\N$.
    \begin{enumerate}
        \item\label{properties-of-observational-equality-of-natural-numbers-reflexivity}\SloganFont{Reflexivity. }There exists a term
            \[
                \reflEq_{\N}%
                \oftype%
                \prod_{n\oftype\N}\sfEq_{\N}(n,n)%
            \]%
            defined via pattern matching by
            \begin{align*}
                \reflEq_{\N}(0_{\N})        &\defeq \UnitType,\\%
                \reflEq_{\N}(\succ_{\N}(n)) &\defeq \reflEq_{\N}(n).%
            \end{align*}
        \item\label{properties-of-observational-equality-of-natural-numbers-relation-to-identity-types}\SloganFont{Relation to Identity Types. }The type
            \[
                (n\equals_{\N}m)%
                \biimplications%
                \sfEq_{\N}(n,m)%
            \]%
            is inhabited.
        %\item\label{properties-of-observational-equality-of-natural-numbers-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-observational-equality-of-natural-numbers}}%
    \FirstProofBox{\cref{properties-of-observational-equality-of-natural-numbers-reflexivity}: Reflexivity}%
    There is nothing to prove.

    \ProofBox{\cref{properties-of-observational-equality-of-natural-numbers-relation-to-identity-types}: Relation to Identity Types}%
    We define a function
    \[
        (n\equals_{\N}m)%
        \to%
        \sfEq_{\N}(n,m)%
    \]%
    via path induction, using $\reflEq_{\N}$:
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{n\oftype\N}}%
            \hypo{\context{\Gamma,\,m\oftype\N,\,p\oftype n\equals_{\N}m}{\sfEq_{\N}(n,m)\type}}%
            \infer2[(id-ind)]{\context{\Gamma}{\displaystyle\indeq{n}\oftype\sfEq_{\N}(n,n)\to\prod_{m\oftype\N}\prod_{p\oftype n\equals_{\N}m}\sfEq_{\N}(n,m)}}%
            \infer1{\context{\Gamma}{\displaystyle\indeq{n}(\reflEq_{\N}(n))\oftype\prod_{m\oftype\N}\prod_{p\oftype n\equals_{\N}m}\sfEq_{\N}(n,m)}}
            \infer1{\context{\Gamma}{\displaystyle[\indeq{n}(\reflEq_{\N}(n))](m)\oftype\prod_{p\oftype n\equals_{\N}m}\sfEq_{\N}(n,m)}}%
            \infer1{\context{\Gamma}{\displaystyle[\indeq{n}(\reflEq_{\N}(n))](m)\oftype(n\equals_{\N}m)\to\sfEq_{\N}(n,m)}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    To define a function $\sfEq_{\N}(n,m)\to(n\equals_{\N}m)$, we proceed by induction on $n$ and $m$.
    \begin{itemize}
        \item If $n=m=0_{\N}$, we have $\refl_{0_{\N}}\oftype0_{\N}\to0_{\N}$.
        \item If $n=0_{\N}$ and $m=\succ_{\N}(k)$ for some $k\oftype\N$ or the other way around, we have a function $\EmptyType\to(n\equals_{\N}m)$.
        \item If $n$ and $m$ are successors and we assume we have a function $f\oftype\sfEq_{\N}(n,m)\to(n\equals_{\N}m)$ for induction, then we define
            \[
                \sfEq_{\N}(\succ_{\N}(n),\succ_{\N}(m))%
                \to%
                (\succ_{\N}(n)\equals_{\N}\succ_{\N}(m))%
            \]%
            as the composition
            \[
                \begin{tikzcd}[row sep={0.0*\the\DL,between origins}, column sep={0.0*\the\DL,between origins}, background color=backgroundColor, ampersand replacement=\&]
                    {\sfEq_{\N}(\succ_{\N}(n),\succ_{\N}(m))}
                    \&[0.5\ThreeCm]
                    \&[0.9\ThreeCm]
                    \&[0.5\ThreeCm]
                    {(\succ_{\N}(n)\equals_{\N}\succ_{\N}(m))\mrp{,}}
                    \\[0.5\ThreeCm]
                    \&[0.5\ThreeCm]
                    {\sfEq_{\N}(n,m)}
                    \&[0.9\ThreeCm]
                    {(n\equals_{\N}m)}
                    \&[0.5\ThreeCm]
                    % 1-Arrows
                    \arrow[from=1-1,to=1-4,dashed]%
                    %
                    \arrow[from=1-1,to=2-2,"\sfid"',pos=0.325]%
                    \arrow[from=2-2,to=2-3,"f"']%
                    \arrow[from=2-3,to=1-4,"\ap_{\succ_{\N}}"',pos=0.525]%
                \end{tikzcd}
            \]%
            where $\sfid$ is the identity function, as we have a judgemental equality $\sfEq_{\N}(\succ_{\N}(n),\succ_{\N}(m))\doteq\sfEq_{\N}(n,m)$.
    \end{itemize}
    This finishes the proof.
\end{Proof}
\subsection{Addition of Natural Numbers}\label{subsection-martin-löf-type-theory-addition-of-natural-numbers}
\begin{definition}{Addition of Natural Numbers}{addition-of-natural-numbers}%
    The \index[type-theory]{natural numbers!addition}\index[type-theory]{addition of natural numbers}\textbf{addition} of natural numbers is the function\index[notation]{addN@$\add_{\N}$}%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Notation: }We write \index[notation]{nplusm@$n+m$}$n+m$ for $\add_{\N}(n,m)$. The computation rules for addition then look like
        \[
            \begin{gathered}
                n+0_{\N}        \doteq n,\\
                n+\succ_{\N}(m) \doteq \succ_{\N}(n+m)
            \end{gathered}
        \]%
        for each $n,m\oftype\N$.
        \par\vspace*{\TCBBoxCorrection}
    }%
    %---  End Footnote  ---%
    \[
        \add_{\N}%
        \oftype%
        \N%
        \to%
        [\N,\N]%
    \]%
    defined via the following two specifications:%
    \begin{enumerate}
        \item\label{addition-of-natural-numbers-the-base-case}\SloganFont{The Base Case. }We have
            \[
                \add_{\N}(n,0_{\N})%
                \doteq%
                n%
                {\color{OIblue}\oftype\N}.%
            \]%
        \item\label{addition-of-natural-numbers-the-inductive-step}\SloganFont{The Inductive Step. }We have
            \[
                \add_{\N}(n,\succ_{\N}(m))%
                \doteq%
                \succ_{\N}(\add_{\N}(n,m))%
                {\color{OIblue}\oftype\N}.%
            \]%
    \end{enumerate}
\end{definition}
\begin{Proof}{Construction of $\add_{\N}$}%
    We construct $\add_{\N}$ via induction on its second variable, constructing
    \[
        \context{n,\,\N}{\add_{\N}(n)\oftype\N\to\N}.%
    \]%
    We will thus take our context ${\color{OIvermillion}\Gamma}$ to be ${\color{OIvermillion}n\oftype\N}$, and use the induction principle of $\N$ with the family of types $P(m)\doteq\N$ indexed by $m\oftype\N$ in context ${\color{OIvermillion}n\oftype\N}$. Moreover:
    \begin{itemize}
        \item $p_{0}\oftype P(0_{\N})$ will be a term of the form
            \[
                \addzero_{\N}(n)%
                \oftype%
                \N.%
            \]%
        \item $p_{S}\oftype\prod_{n\oftype\N}P(n)\to P(\succ_{\N}(n))$ will be a term of the form
            \[
                \addsucc_{\N}(n)%
                \oftype%
                \prod_{n\oftype\N}(\N\to\N)%
            \]%
            i.e.\ a term $\addsucc_{\N}(n)\oftype\N\to[\N,\N]$.
    \end{itemize}

    \ProofBox{The Base Case}%
    We want to construct $\context{n\oftype\N}{\addzero_{\N}(n)\oftype\N}$. For this, we have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{n\oftype\N}{n\oftype\N}}%
            \infer1{\context{n\oftype\N}{\addzero_{\N}(n)\doteq n\oftype\N}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%

    \ProofBox{The Inductive Step}%
    We want to construct $\context{n\oftype\N}{\addsucc_{\N}(n)\oftype\N\to[\N,\N]}$. For this, we have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{}%
            \infer1[($\N$-form)]{\vdash\N\type}%
            \hypo{}%
            \infer1[($\N$-succ)]{\vdash\succ_{\N}\oftype\N\to\N}%
            \hypo{}%
            \infer1[($\N$-form)]{\vdash\N\type}%
            \infer2{\context{m\oftype\N}{\succ_{\N}\oftype\N\to\N}}%
            \infer2{\context{n\oftype\N,\,m\oftype\N}{\succ_{\N}\oftype\N\to\N}}%
            \infer1[(λ)]{\context{n\oftype\N}{\llbracket m\mapsto\succ_{\N}\rrbracket\oftype\N\to[\N,\N]}}%
            \infer1[(add-succ)]{\context{n\oftype\N}{\addsucc_{\N}(n)\doteq\llbracket m\mapsto\succ_{\N}\rrbracket\oftype\N\to[\N,\N]}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%

    \ProofBox{Wrapping Up}%
    The induction principle for $\N$ then gives us
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,n\oftype\N}{\N\type}}%
            \hypo{\evdots}%
            \infer1{\context{n\oftype\N}{\addzero_{\N}(n)\doteq n\oftype\N}}%
            \hypo{\evdots}%
            \infer1{\context{n\oftype\N}{\addsucc_{\N}(n)\oftype\N\to[\N,\N]}}%
            \infer3[($\N$-ind1)]{\context{n\oftype\N}{\ind_{\N}(\addzero_{\N}(n),\addsucc_{\N}(n))\oftype\N\to\N}}%
            \infer1{\context{n\oftype\N}{\add_{\N}(n)\doteq\ind_{\N}(\addzero_{\N}(n),\addsucc_{\N}(n))\oftype\N\to\N}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the construction of $\add_{\N}$.

    \ProofBox{\cref{addition-of-natural-numbers-the-base-case,addition-of-natural-numbers-the-inductive-step}}%
    This follows from the computation rules of $\N$.
\end{Proof}
\begin{proposition}{Properties of Addition}{properties-of-addition}%
    Let $n\oftype\N$ and $m\oftype\N$.
    \begin{enumerate}
        \item\label{properties-of-addition-unitality}\SloganFont{Unitality. }There exists terms
            \begin{align*}
                \zeroadd_{\N}\oftype 0_{\N}+n\equals_{\N}n,\\
                \addzero_{\N}\oftype n+0_{\N}\equals_{\N}n.
            \end{align*}
        \item\label{properties-of-addition-interaction-with-successors}\SloganFont{Interaction With Successors. }There exists terms
            \begin{align*}
                \succadd_{\N}\oftype \succ_{\N}(n)+m\equals_{\N}\succ_{\N}(n+m),\\
                \addsucc_{\N}\oftype n+\succ_{\N}(m)\equals_{\N}\succ_{\N}(n+m).
            \end{align*}
        \item\label{properties-of-addition-associativity}\SloganFont{Associativity. }There exists a term
            \[
                \assoc^{+}_{\N}%
                \oftype%
                (n+m)+k%
                \equals_{\N}
                n+(m+k).%
            \]%
        \item\label{properties-of-addition-commutativity}\SloganFont{Commutativity. }There exists a term
            \[
                \comm^{+}_{\N}%
                \oftype%
                n+m%
                \equals_{\N}%
                m+n.%
            \]%
        \item\label{properties-of-addition-successors-via-addition}\SloganFont{Successors via Addition. }There exists a term
            \[
                \succasadd_{\N}%
                \oftype%
                \succ_{\N}(n)%
                \equals_{\N}%
                n+1_{\N}.%
            \]%
        %\item\label{properties-of-addition-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-addition}}%
    \FirstProofBox{\cref{properties-of-addition-unitality}: Unitality}%
    Since the computation rules for addition guarantee that $n+0_{\N}\doteq n$, we may define
    \[
        \addzero_{\N}%
        \defeq%
        \refl_{n}.%
    \]%
    To define $\zeroadd$, we proceed by induction on $n$.
    \begin{itemize}
        \item\SloganFont{The Base Case. }We have to produce a term of type $0_{\N}+0_{\N}\equals_{\N}0_{\N}$, for which we use $\refl_{0_{\N}}$.
        \item\SloganFont{The Induction Step. }Assume we have a term $p\oftype 0_{\N}+n\equals_{\N}n$. We have to produce a term of type
            \[
                0_{\N}+\succ_{\N}(n)%
                \equals_{\N}%
                \succ_{\N}(n).%
            \]%
            By the computation rules for addition, we have $0_{\N}+\succ_{\N}(n)\doteq\succ_{\N}(0_{\N}+n)$, so this is the same as producing a term of type
            \[
                \succ_{\N}(0_{\N}+n)%
                \equals_{\N}%
                \succ_{\N}(n).%
            \]%
            Applying the action on identifications
            \[
                \ap_{\succ_{\N}}%
                \oftype%
                \prod_{{\color{OIblue}k,\ell\oftype\N}}{\color{OIblue}k\equals_{\N}\ell}\mathbin{\color{OIvermillion}{\to}}{\color{OIblue}\succ_{\N}(k)\equals_{\N}\succ_{\N}(\ell)}%
            \]%
            of $\succ_{\N}\oftype\N\to\N$ to $p$, we obtain a term
            \[
                \ap_{\succ_{\N}}(p)%
                \oftype%
                \succ_{\N}(0_{\N}+n)%
                \equals_{\N}%
                \succ_{\N}(n).%
            \]%
            This finishes the inductive step.
    \end{itemize}
    We then define
    \[
        \zeroadd_{\N}%
        \defeq%
        \ind_{\N}(\refl_{0_{\N}},\llbracket p\mapsto\ap_{\succ_{\N}}(p)\rrbracket).%
    \]%
    This finishes the proof.

    \ProofBox{\cref{properties-of-addition-interaction-with-successors}: Interaction With Successors}%
    Since the computation rules for addition give us a judgemental equality
    \[
        n+\succ_{\N}(m)%
        \doteq%
        \succ_{\N}(n+m),%
    \]%
    we may define
    \[
        \addsucc_{\N}%
        \defeq%
        \refl_{n+m}.%
    \]%
    To define $\succadd$, we proceed by induction on $n$.
    \begin{itemize}
        \item\SloganFont{The Base Case. }We have to produce a term of type
            \[
                \succ_{\N}(n)+0_{\N}%
                \equals_{\N}%
                \succ_{\N}(n+0_{\N}).%
            \]%
            Since $n+0_{\N}\doteq n$, we may use $\refl_{n}$.
        \item\SloganFont{The Induction Step. }Assume we have a term
            \[
                p%
                \oftype%
                \succ_{\N}(n)+m%
                \equals_{\N}%
                \succ_{\N}(n+m).%
            \]%
            We have to produce a term of type
            \[
                \succ_{\N}(n)+\succ_{\N}(m)%
                \equals_{\N}%
                \succ_{\N}(n+\succ_{\N}(m))%
            \]%
            By the computation rules for addition, we have judgemental equalities
            \[
                \underbrace{\succ_{\N}(n)+\succ_{\N}(m)}_{{}\doteq\succ_{\N}(\succ_{\N}(n)+m)}%
                \equals_{\N}%
                \underbrace{\succ_{\N}(n+\succ_{\N}(m))}_{{}\doteq\succ_{\N}(\succ_{\N}(n+m))},%
            \]%
            so it suffices to construct a term of type
            \[
                \succ_{\N}(\succ_{\N}(n)+m)%
                \equals_{\N}%
                \succ_{\N}(\succ_{\N}(n+m)).%
            \]%
            Applying the action on identifications
            \[
                \ap_{\succ_{\N}}%
                \oftype%
                \prod_{{\color{OIblue}k,\ell\oftype\N}}{\color{OIblue}k\equals_{\N}\ell}\mathbin{\color{OIvermillion}{\to}}{\color{OIblue}\succ_{\N}(k)\equals_{\N}\succ_{\N}(\ell)}%
            \]%
            of $\succ_{\N}\oftype\N\to\N$ to $p$, we obtain a term
            \[
                \ap_{\succ_{\N}}(p)%
                \oftype%
                \succ_{\N}(\succ_{\N}(n)+m)%
                \subequals_{\N}%
                \succ_{\N}(\succ_{\N}(n+m)).%
            \]%
            This finishes the inductive step.
    \end{itemize}
    We then define
    \[
        \succadd_{\N}%
        \defeq%
        \ind_{\N}(\refl_{n},\llbracket p\mapsto\ap_{\succ_{\N}}(p)\rrbracket).%
    \]%
    This finishes the proof.

    \ProofBox{\cref{properties-of-addition-associativity}: Associativity}%
    We proceed by induction on $k$.
    \begin{itemize}
        \item\SloganFont{The Base Case. }We have to produce a term of type
            \[
                (n+m)+0_{\N}%
                \equals_{\N}%
                n+(m+0_{\N}).%
            \]%
            Since $n+0_{\N}\doteq n$ for all $n\oftype\N$, we may use $\refl_{n+m}$.
        \item\SloganFont{The Induction Step. }Assume we have a term
            \[
                p%
                \oftype%
                (n+m)+k%
                \equals_{\N}%
                n+(m+k).%
            \]%
            We have to produce a term of type
            \[
                (n+m)+\succ_{\N}(k)%
                \equals_{\N}%
                n+(m+\succ_{\N}(k)).%
            \]%
            By the computation rules for addition, we have judgemental equalities
            \[
                \underbrace{(n+m)+\succ_{\N}(k)}_{{}\doteq\succ_{\N}((n+m)+k)}%
                \equals_{\N}%
                \underbrace{n+(m+\succ_{\N}(k))}_{{}\doteq\succ_{\N}(n+(m+k))},%
            \]%
            so it suffices to construct a term of type
            \[
                \succ_{\N}((n+m)+k)%
                \equals_{\N}%
                \succ_{\N}(n+(m+k)).%
            \]%
            Applying the action on identifications
            \[
                \ap_{\succ_{\N}}%
                \oftype%
                \prod_{{\color{OIblue}k,\ell\oftype\N}}{\color{OIblue}k\equals_{\N}\ell}\mathbin{\color{OIvermillion}{\to}}{\color{OIblue}\succ_{\N}(k)\equals_{\N}\succ_{\N}(\ell)}%
            \]%
            of $\succ_{\N}\oftype\N\to\N$ to $p$, we obtain a term
            \[
                \ap_{\succ_{\N}}(p)%
                \oftype%
                \succ_{\N}((n+m)+k)%
                \equals_{\N}%
                \succ_{\N}(n+(m+k)).%
            \]%
            This finishes the inductive step.
    \end{itemize}
    We then define
    \[
        \assoc^{+}_{\N}%
        \defeq%
        \ind_{\N}(\refl_{n+m},\llbracket p\mapsto\ap_{\succ_{\N}}(p)\rrbracket).%
    \]%
    This finishes the proof.

    \ProofBox{\cref{properties-of-addition-commutativity}: Commutativity}%
    We proceed by induction on $n$.
    \begin{itemize}
        \item\SloganFont{The Base Case. }We have to produce a term of type
            \[
                0_{\N}+m%
                \equals_{\N}%
                m+0_{\N}.%
            \]%
            Since $m+0_{\N}\doteq m$, we may use $\zeroadd_{\N}$.
        \item\SloganFont{The Induction Step. }Assume we have a term
            \[
                p%
                \oftype%
                n+m%
                \equals_{\N}%
                m+n.%
            \]%
            We have to produce a term of type
            \[
                \succ_{\N}(n)+m%
                \equals_{\N}%
                m+\succ_{\N}(n).%
            \]%
            By the computation rules for addition, we have $m+\succ_{\N}(n)\doteq\succ_{\N}(m+n)$ and $\succadd_{\N}$ gives us a term
            \[
                \succadd_{\N}(n,m)%
                \oftype%
                \succ_{\N}(n)+m%
                \equals_{\N}%
                \succ_{\N}(n+m),%
            \]%
            so it only remains to construct a term of type $\succ_{\N}(n+m)\equals_{\N}\succ_{\N}(m+n)$. Again $\ap_{\succ_{\N}}$ fits the bill. This finishes the inductive step.
    \end{itemize}
    We then define
    \[
        \comm^{+}_{\N}%
        \defeq%
        \ind_{\N}(\zeroadd_{\N},\llbracket p\mapsto\ap_{\succ_{\N}}(p)\ccirc\succadd_{\N}\rrbracket).%
    \]%
    This finishes the proof.

    \ProofBox{\cref{properties-of-addition-successors-via-addition}: Successors via Addition}%
    Omitted.
\end{Proof}
\subsection{Multiplication of Natural Numbers}\label{subsection-martin-löf-type-theory-multiplication-of-natural-numbers}
\begin{definition}{Multiplication of Natural Numbers}{multiplication-of-natural-numbers}%
    The \index[type-theory]{natural numbers!multiplication}\index[type-theory]{multiplication of natural numbers}\textbf{multiplication} of natural numbers is the function\index[notation]{multN@$\mult_{\N}$}%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Notation: }We write \index[notation]{ntimesm@$n\cdot m$}$n\cdot m$ for $\mult_{\N}(n,m)$.
        \par\vspace*{\TCBBoxCorrection}
    }%
    %---  End Footnote  ---%
    \[
        \mult_{\N}%
        \oftype%
        \N%
        \to%
        [\N,\N]%
    \]%
    defined via pattern matching with the following specifications:%
    \begin{align*}
        \mult_{\N}(n,0_{\N})        &\defeq 0_{\N},\\
        \mult_{\N}(n,\succ_{\N}(m)) &\defeq n+\succ_{\N}(\mult_{\N}(n,m)).%
    \end{align*}
\end{definition}
\begin{proposition}{Properties of Multiplication}{properties-of-multiplication}%
    Let $n\oftype\N$ and $m\oftype\N$.
    \begin{enumerate}
        \item\label{properties-of-multiplication-unitality}\SloganFont{Unitality. }name stuff onemult and multone
        \item\label{properties-of-multiplication-associativity}\SloganFont{Associativity. }
        \item\label{properties-of-multiplication-commutativity}\SloganFont{Commutativity. }
        %\item\label{properties-of-multiplication-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-multiplication}}%
    \FirstProofBox{\cref{properties-of-multiplication-unitality}: Unitality}%
    Omitted.

    \ProofBox{\cref{properties-of-multiplication-associativity}: Associativity}%
    Omitted.

    \ProofBox{\cref{properties-of-multiplication-commutativity}: Commutativity}%
    Omitted.
\end{Proof}
\subsection{Exponentiation of Natural Numbers}\label{subsection-martin-löf-type-theory-exponentiation-of-natural-numbers}
\begin{definition}{Exponentiation of Natural Numbers}{exponentiation-of-natural-numbers}%
    The \index[type-theory]{natural numbers!exponentiation}\index[type-theory]{exponentiation of natural numbers}\textbf{exponentiation} of natural numbers is the function%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Notation: }We write \index[notation]{ntothem@$n^{m}$}$n^{m}$ for $\sfexp_{\N}(n,m)$.
        \par\vspace*{\TCBBoxCorrection}
    }%
    %---  End Footnote  ---%
    \[
        \exp_{\N}%
        \oftype%
        \N%
        \to%
        [\N,\N]%
    \]%
    defined via pattern matching with the following specifications:%
    \begin{align*}
        \exp_{\N}(n,0_{\N})        &\defeq 1_{\N},\\
        \exp_{\N}(n,\succ_{\N}(m)) &\defeq n\succ_{\N}(\mult_{\N}(n,m)).%
    \end{align*}
\end{definition}
\begin{proposition}{Properties of Exponentiation}{properties-of-exponentiation}%
    Let $n\oftype\N$ and $m\oftype\N$.
    \begin{enumerate}
        \item\label{properties-of-exponentiation-unitality}\SloganFont{Unitality. }
        \item\label{properties-of-exponentiation-associativity}\SloganFont{Associativity. }
        \item\label{properties-of-exponentiation-commutativity}\SloganFont{Commutativity. }
        %\item\label{properties-of-exponentiation-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-exponentiation}}%
    \FirstProofBox{\cref{properties-of-exponentiation-unitality}: Unitality}%
    Omitted.

    \ProofBox{\cref{properties-of-exponentiation-associativity}: Associativity}%
    Omitted.

    \ProofBox{\cref{properties-of-exponentiation-commutativity}: Commutativity}%
    Omitted.
\end{Proof}
\section{The Integers}\label{section-martin-löf-type-theory-the-integers}
\subsection{Foundations}\label{subsection-martin-löf-type-theory-the-integers-foundations}
\begin{definition}{The Type of Integers}{the-type-of-integers}%
    The \index[type-theory]{type of integers}\textbf{type of integers} is the type \index[notation]{Z@$\Z$}$\Z$ defined by
    \[
        \Z%
        \defeq%
        \N+(\UnitType+\N).%
    \]%
\end{definition}
\begin{remark}{Unwinding \cref{the-type-of-integers}}{unwinding-the-type-of-integers}%
    The type of integers $\Z$ comes with:
    \begin{enumerate}
        \item\label{unwinding-the-type-of-integers-1}Functions
            \begin{align*}
                \iota^{\sfpos}_{\Z} &\oftype\N\to\Z,\\%
                \iota^{\sfneg}_{\Z} &\oftype\N\to\Z
            \end{align*}
            defined by
            \begin{align*}
                \iota^{\sfpos}_{\Z} &\defeq \iota^{\rmR}_{\N+(\UnitType+\N)}\circ\iota^{\rmR}_{\UnitType+\N},\\
                \iota^{\sfneg}_{\Z} &\defeq \iota^{\rmL}_{\N+(\UnitType+\N)}.
            \end{align*}
        \item\label{unwinding-the-type-of-integers-2}Constants
            \begin{align*}
                -1_{\Z} &\defeq \iota^{\sfneg}_{\Z}(1_{\N}),\\%
                0_{\Z}  &\defeq \iota^{\rmR}_{\N+(\UnitType+\N)}\left(\iota^{\rmL}_{\UnitType+\N}(\point)\right),\\%
                1_{\Z}  &\defeq \iota^{\sfpos}_{\Z}(1_{\N}).%
            \end{align*}
    \end{enumerate}
    We may picture the definition of $\Z$ as the coproduct type $\N+(\UnitType+\N)$ as follows:
    \[
        \begin{tikzcd}[row sep={3.5*\the\DL,between origins}, column sep={3.5*\the\DL,between origins}, background color=backgroundColor, ampersand replacement=\&]
            \&
            \UnitType
            \&
            \&
            \N
            \\
            \N
            \&
            \&
            \UnitType+\N%
            \&
            \\
            \&
            \Z
            \&
            \&
            % 1-Arrows
            \arrow[from=1-2,to=2-3,hook]%
            \arrow[from=1-4,to=2-3,hook']%
            %
            \arrow[from=2-1,to=3-2,hook]%
            \arrow[from=2-3,to=3-2,hook']%
        \end{tikzcd}
    \]%
    The type of integers $\Z$ also comes with the following induction principle (derived from the ones from $\N$ and those from coproduct types):
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,k\oftype\Z}{P(k)\type}}%
            \hypo{\context{\Gamma}{p_{-1}\oftype P(-1_{\Z})}}%
            \hypo{\context{\Gamma}{p_{0}\oftype P(0_{\Z})}}%
            \hypo{\context{\Gamma}{p_{1}\oftype P(1_{\Z})}}%
            \hypo{\context{\Gamma}{\displaystyle p_{-S}\oftype\prod_{n\oftype\N}P(n)\to P\left(\iota^{\sfneg}_{\Z}(\succ_{\N}(n))\right)}}%
            \hypo{\context{\Gamma}{\displaystyle p_{S} \oftype\prod_{n\oftype\N}P(n)\to P\left(\iota^{\sfpos}_{\Z}(\succ_{\N}(n))\right)}}%
            \infer6[($\Z$-ind)]{\context{\Gamma}{\displaystyle\ind_{\Z}(p_{-1},p_{0},p_{1},p_{-S},p_{S})\oftype\prod_{k\oftype\Z}P(k)}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
\end{remark}
\subsection{Addition of Integers}\label{subsection-martin-löf-type-theory-addition-of-integers}
TODO:
\begin{itemize}
    \item predecessor function
    \item negation function $k\mapsto-k$
    \item 
\end{itemize}
\subsection{Multiplication of Integers}\label{subsection-martin-löf-type-theory-multiplication-of-integers}
\subsection{Exponentiation of Integers}\label{subsection-martin-löf-type-theory-exponentiation-of-integers}
\section{Constructions With Types}\label{section-constructions-with-types}
\subsection{The Unit Type}\label{subsection-the-unit-type}
\begin{definition}{The Unit Type}{the-unit-type}%
    The \index[type-theory]{unit type}\textbf{unit type} is the type $\UnitType$ equipped with a term $\point\oftype\UnitType$ satisfying the following induction principle:
    \begin{itemize}
        \itemstar Given a type family $P$ indexed over $x\oftype\UnitType$, there exists a function
            \[
                \ind_{\UnitType}%
                \oftype%
                P(\point)%
                \to%
                \prod_{x\oftype\UnitType}P(x)%
            \]%
            for which the computation rule
            \[
                \ind_{\UnitType}(p,\point)%
                \doteq%
                p%
            \]%
            holds.
    \end{itemize}
\end{definition}
\begin{remark}{Explicit Inference Rules for the Unit Type}{explicit-inference-rules-for-the-unit-type}%
    The unit type has the following inference rules:
    \begin{enumerate}
        \item\label{explicit-inference-rules-for-the-unit-type-formation}\SloganFont{Formation. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{}%
                    \infer1[($\UnitType$-form)]{\vdash\UnitType}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-the-unit-type-introduction}\SloganFont{Introduction. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{}%
                    \infer1[($\UnitType$-point)]{\vdash\point\oftype\UnitType}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-the-unit-type-induction}\SloganFont{Induction. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype\UnitType}{P(x)\type}}%
                    \hypo{\context{\Gamma}{p\oftype P(\point)}}%
                    \infer2[($\UnitType$-ind)]{\context{\Gamma}{\displaystyle\ind_{\UnitType}(p,\point)\oftype\prod_{x\oftype\UnitType}P(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-the-unit-type-computation}\SloganFont{Computation. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype\UnitType}{P(x)\type}}%
                    \hypo{\context{\Gamma}{p\oftype P(\point)}}%
                    \infer2[($\UnitType$-comp)]{\context{\Gamma}{\displaystyle\ind_{\UnitType}(p,\point)\doteq p\oftype\prod_{x\oftype\UnitType}P(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{remark}
\begin{example}{From Terms $x\oftype A$ to Functions $\pt_{x}\oftype\UnitType\to A$}{from-terms-x-oftype-a-to-functions-pt-x-oftype-unittype-to-a}%
    The induction principle of the unit type allows us to construct a function $\pt_{x}\oftype\UnitType\to A$ from a term $x\oftype A$:
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{x\oftype A}}%
            \infer1{\context{\Gamma}{A\type}}%
            \infer1[(W)]{\context{\Gamma,\,x\oftype\UnitType}{A\type}}%
            \hypo{\context{\Gamma}{x\oftype A}}%
            \infer2[($\UnitType$-ind)]{\context{\Gamma}{\displaystyle\ind_{\UnitType}(x,\point)\oftype\prod_{x\oftype\UnitType}A}}%
            \infer1{\context{\Gamma}{\ind_{\UnitType}(x,\point)\oftype\UnitType\to A}}%
            \infer1{\context{\Gamma}{\pt_{x}\doteq\ind_{\UnitType}(x,\point)\oftype\UnitType\to A}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
\end{example}
\subsection{The Empty Type}\label{subsection-the-empty-type}
\begin{definition}{The Empty Type}{the-empty-type}%
    The \index[type-theory]{empty type}\textbf{empty type} is the type $\EmptyType$ satisfying the following induction principle:
    \begin{itemize}
        \itemstar Given a type family $P$ indexed over $x\oftype\EmptyType$, there exists a function
            \[
                \ind_{\EmptyType}%
                \oftype%
                \prod_{x\oftype\EmptyType}P(x).%
            \]%
    \end{itemize}
\end{definition}
\begin{remark}{Explicit Inference Rules for the Empty Type}{explicit-inference-rules-for-the-empty-type}%
    The unit type has the following inference rules:
    \begin{enumerate}
        \item\label{explicit-inference-rules-for-the-empty-type-formation}\SloganFont{Formation. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{}%
                    \infer1[($\EmptyType$-form)]{\vdash\EmptyType}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-the-empty-type-induction}\SloganFont{Induction. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype\EmptyType}{P(x)\type}}%
                    \infer1[($\EmptyType$-ind)]{\context{\Gamma}{\displaystyle\ind_{\EmptyType}\oftype\prod_{x\oftype\EmptyType}P(x)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{remark}
\begin{example}{The $\exfalso$ Function}{the-exfalso-function}%
    The induction principle of the empty type allows us to construct a function
    \[
        \exfalso%
        \oftype%
        \EmptyType\to A%
    \]%
    via the derivation
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{x\oftype A}}%
            \infer1{\context{\Gamma}{A\type}}%
            \infer1[(W)]{\context{\Gamma,\,x\oftype\EmptyType}{A\type}}%
            \infer1[($\EmptyType$-ind)]{\context{\Gamma}{\displaystyle\ind_{\EmptyType}\oftype\prod_{x\oftype\EmptyType}A}}%
            \infer1{\context{\Gamma}{\ind_{\EmptyType}\oftype\EmptyType\to A}}%
            \infer1{\context{\Gamma}{\exfalso\doteq\ind_{\EmptyType}\oftype\EmptyType\to A}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
\end{example}
\subsection{Coproduct Types}\label{subsection-coproduct-types}
Let $A$ and $B$ be types.
\begin{definition}{Coproduct Types}{coproduct-types}%
    The \index[type-theory]{coproduct type}\textbf{coproduct type}%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology: }Also called the \index[type-theory]{direct sum type|see {coproduct type}}\textbf{direct sum} of $A$ and $B$.
        \par\vspace*{\TCBBoxCorrection}
    } %
    %---  End Footnote  ---%
    of $A$ and $B$ is the type \index[notation]{AplusB@$A+B$}$A+B$ equipped with terms
    \begin{align*}
        \iota^{\rmL}_{A+B} &\oftype A\to A+B,\\%
        \iota^{\rmR}_{A+B} &\oftype B\to A+B%
    \end{align*}
    satisfying the following induction principle:
    \begin{itemize}
        \itemstar Given a type family $P$ indexed over $x\oftype A+B$, there exists a function
            \[
                \ind_{+}%
                \oftype%
                \prod_{x\oftype A}P\left(\iota^{\rmL}_{A+B}(x)\right)%
                \to
                \left[\prod_{y\oftype B}P\left(\iota^{\rmR}_{A+B}(y)\right),\prod_{z\oftype A+B}P(x)\right]
            \]%
            for which the computation rules
            \begin{align*}
                \ind_{+}\left(f,g,\iota^{\rmL}_{A+B}(x)\right) &\doteq f(x),\\
                \ind_{+}\left(f,g,\iota^{\rmR}_{A+B}(x)\right) &\doteq g(y).
            \end{align*}
            hold.
    \end{itemize}
\end{definition}
\begin{remark}{Explicit Inference Rules for Coproduct Types}{explicit-inference-rules-for-coproduct-types}%
    Coproduct types have the following inference rules:
    \begin{enumerate}
        \item\label{explicit-inference-rules-for-coproduct-types-formation}\SloganFont{Formation. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \infer2{\context{\Gamma}{A+B\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-coproduct-types-introduction-1}\SloganFont{Introduction \rmI. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \infer2{\context{\Gamma}{\iota^{\rmL}_{A+B}\oftype A\to A+B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-coproduct-types-introduction-2}\SloganFont{Introduction \rmII. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \infer2{\context{\Gamma}{\iota^{\rmR}_{A+B}\oftype B\to A+B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-coproduct-types-induction}\SloganFont{Induction. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A+B}{P(x)\type}}%
                    \infer1{\context{\Gamma}{\displaystyle\prod_{x\oftype A}P\left(\iota^{\rmL}_{A+B}(x)\right)\to\left[\prod_{y\oftype B}P\left(\iota^{\rmR}_{A+B}(y)\right),\prod_{z\oftype A+B}P(x)\right]}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-coproduct-types-computation-1}\SloganFont{Computation \rmI. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A+B}{P(x)\type}}%
                    \hypo{\context{\Gamma}{f\oftype A\to X}}%
                    \hypo{\context{\Gamma}{g\oftype B\to X}}%
                    \infer3{\context{\Gamma}{\displaystyle\ind_{+}\left(f,g,\iota^{\rmL}_{A+B}(x)\right)\doteq f(x)\oftype X}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-coproduct-types-computation-2}\SloganFont{Computation \rmII. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma,\,x\oftype A+B}{P(x)\type}}%
                    \hypo{\context{\Gamma}{f\oftype A\to X}}%
                    \hypo{\context{\Gamma}{g\oftype B\to X}}%
                    \infer3{\context{\Gamma}{\displaystyle\ind_{+}\left(f,g,\iota^{\rmR}_{A+B}(x)\right)\doteq g(x)\oftype X}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{remark}
\begin{example}{Recovering the Universal Property of Coproducts}{recovering-the-universal-property-of-coproducts}%
    The induction principle for coproduct types allows us to construct a function
    \[
        \ind_{+}%
        \oftype%
        [A,X]%
        \to%
        [[B,X],[A+B,X]]%
    \]%
    via the derivation
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,x\oftype A+B}{X\type}}%
            \infer1[(ind)]{\context{\Gamma}{\displaystyle\prod_{x\oftype A}X\to\left[\prod_{y\oftype B}X,\prod_{z\oftype A+B}X\right]}}%
            \infer1{\context{\Gamma}{\displaystyle[A,X]\to\left[[B,X],[A+B,X]\right]}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
\end{example}
\subsection{Dependent Pair Types}\label{subsection-dependent-pair-types}
Let $A$ be a type and let $B$ be a type family over $A$.
\begin{definition}{Dependent Pair Types}{dependent-pair-types}%
    The \index[type-theory]{dependent pair type}\textbf{dependent pair type}%
    %--- Begin Footnote ---%
    \footnote{%
        Also called the \index[type-theory]{Σ-type}\textbf{Σ-type} of $B(x)$ over $A$.
    } %
    %---  End Footnote  ---%
    of $B(x)$ over $A$ is the type \index[notation]{sumxoftypeABx@$\sum_{x\oftype A}B(x)$}$\sum_{x\oftype A}B(x)$ equipped with a \index[type-theory]{pairing function}\textbf{pairing function}%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Notation: }We also write simply $(x,y)$ for $\pair(x,y)$.
        \par\vspace*{\TCBBoxCorrection}
    }%
    %---  End Footnote  ---%
    \[
        \pair%
        \oftype%
        \left(\prod_{x\oftype A}B(x)\right)\to\left(\sum_{y\oftype A}B(y)\right)%
    \]%
    satisfying the following induction principle:
    \begin{itemize}
        \itemstar Given a type family $P$ indexed over $p\oftype\sum_{x\oftype A}B(x)$, there exists a function
            \begin{webcompile}
                \ind_{\Sigma}%
                \oftype%
                \left(\prod_{x\oftype A}\prod_{y\oftype B(x)}P(\pair(x,y))\right)%
                \to%
                \left(\prod_{\scriptdisplaystyle{\displaystyle z\oftype\sum_{x\oftype A}B(x)}}P(z)\right)%
            \end{webcompile}
            satisfying the computation rule
            \[
                \ind_{\Sigma}(f,\pair(x,y))%
                \doteq%
                f(x,y).
            \]%
    \end{itemize}
\end{definition}
\begin{remark}{Explicit Inference Rules for Dependent Pair Types}{explicit-inference-rules-for-dependent-pair-types}%
    Dependent pair types have the following inference rules:
    \begin{enumerate}
        \item\label{explicit-inference-rules-for-dependent-pair-types-formation}\SloganFont{Formation. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma,\,x\oftype A}{B(x)\type}}%
                    \infer2[(Σ-form)]{\context{\Gamma}{\displaystyle\sum_{x\oftype A}B(x)\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-dependent-pair-types-introduction}\SloganFont{Introduction. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma,\,x\oftype A}{B(x)\type}}%
                    \infer2[(Σ-intro)]{\context{\Gamma}{\displaystyle\pair\oftype\left(\prod_{x\oftype A}B(x)\right)\to\left(\sum_{y\oftype A}B(y)\right)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-dependent-pair-types-induction}\SloganFont{Induction. }We have
            \begin{scalewebprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma,\,x\oftype A}{B(x)\type}}%
                    \hypo{\context{\displaystyle\Gamma,\,z\oftype\sum_{x\oftype A}B(x)}{P(z)\type}}%
                    \infer3[(Σ-ind)]{\context{\Gamma}{\displaystyle\ind_{\Sigma}\oftype\left(\prod_{x\oftype A}\prod_{y\oftype B(x)}P(\pair(x,y))\right)\to\left(\prod_{\scriptdisplaystyle{\displaystyle z\oftype\sum_{x\oftype A}B(x)}}P(z)\right)}}%
                \end{prooftree}%
                .%
            \end{scalewebprooftree}%
        \item\label{explicit-inference-rules-for-dependent-pair-types-computation}\SloganFont{Computation. }We have
            \begin{scalewebprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma,\,x\oftype A}{B(x)\type}}%
                    \hypo{\context{\displaystyle\Gamma,\,z\oftype\sum_{x\oftype A}B(x)}{P(z)\type}}%
                    \hypo{\context{\Gamma}{\displaystyle f\oftype\prod_{\scriptdisplaystyle{z\oftype\sum_{x\oftype A}B(x)}}P(z)}}%
                    \infer4[(Σ-comp)]{\context{\Gamma}{\displaystyle\ind_{\Sigma}(f,\pair(x,y))\doteq f(x,y)\oftype\prod_{\scriptdisplaystyle{\displaystyle z\oftype\sum_{x\oftype A}B(x)}}P(z)}}%
                \end{prooftree}%
                .%
            \end{scalewebprooftree}%
    \end{enumerate}
\end{remark}
\begin{definition}{Projection Functions for Σ-Types}{projection-functions-for-sigma-types}%
    Let $A$ be a type and let $B$ be a type family over $A$.
    \begin{enumerate}
        \item\label{projection-functions-for-sigma-types-the-first-projection-map}The \index[type-theory]{Σ-type!first projection map}\textbf{first projection map} is the function
            \[
                \pr_{1}%
                \oftype%
                \left(\sum_{x\oftype A}B(x)\right)
                \to%
                A%
            \]%
            defined via induction by
            \[
                \pr_{1}(x,y)%
                \defeq%
                x.%
            \]%
        \item\label{projection-functions-for-sigma-types-the-second-projection-map}The \index[type-theory]{Σ-type!second projection map}\textbf{second projection map} is the dependent function
            \begin{webcompile}
                \pr_{2}%
                \oftype%
                \prod_{\scriptdisplaystyle{\displaystyle z\oftype\sum_{x\oftype A}B(x)}}B(\pr_{1}(z))%
            \end{webcompile}
            defined via induction by
            \[
                \pr_{2}(x,y)%
                \defeq%
                y.%
            \]%
    \end{enumerate}
\end{definition}
\begin{proposition}{Properties of Σ-Types}{properties-of-sigma-types}%
    Let $A$ be a type, let $B$ be a type family over $A$, and let $P$ be a type family over $B$.
    \begin{enumerate}
        \item\label{properties-of-sigma-types-currying}\SloganFont{Currying. }There exists a function\index[type-theory]{currying}%
            %--- Begin Footnote ---%
            \footnote{%
                The function $\evpair$ forms a converse to the induction principle for Σ-types, which is thus also called \index[type-theory]{uncurrying}\textbf{uncurrying}.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
            \begin{webcompile}
                \evpair%
                \oftype%
                \left(\prod_{\scriptdisplaystyle{\displaystyle z\oftype\sum_{x\oftype A}B(x)}}P(z)\right)
                \to
                \left(\prod_{x\oftype A}\prod_{y\oftype B(x)}P(x,y)\right).%
            \end{webcompile}
            defined by
            \[
                \evpair(f)%
                \defeq%
                \llbracket x\mapsto\llbracket y\mapsto f(\pair(x,y))\rrbracket\rrbracket.%
            \]%
        %\item\label{properties-of-sigma-types-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-sigma-types}}%
    \FirstProofBox{\cref{properties-of-sigma-types-currying}: Currying}%
    There is nothing to prove.
\end{Proof}
\subsection{Product Types}\label{subsection-product-types}
Let $A$ and $B$ be types.
\begin{definition}{Product Types}{product-types}%
    The \index[type-theory]{product type}\textbf{product type of $A$ and $B$} is the type \index[notation]{AtimesB@$A\times B$}$A\times B$ defined by
    \[
        A\times B%
        \defeq%
        \sum_{x\oftype A}B.%
    \]%
\end{definition}
\begin{remark}{Unwinding \cref{product-types}}{unwinding-product-types}%
    In detail, product types $A\times B$ come with a term
    \[
        \pair%
        \oftype%
        (A\to B)%
        \to%
        A\times B%
    \]%
    satisfying the following induction principle:
    \begin{itemize}
        \itemstar Given a type family $P$ indexed over $z\oftype A\times B$, there exists a function
            \[
                \ind_{\mathord{\times}}%
                \oftype%
                \left(\prod_{x\oftype A}\prod_{y\oftype B}P(x,y)\right)%
                \to%
                \left(\prod_{z\oftype A\times B}P(z)\right)%
            \]%
            satisfying the computation rule
            \[
                \ind_{\mathord{\times}}(f,\pair(x,y))%
                \doteq%
                f(x,y).
            \]%
    \end{itemize}
\end{remark}
\begin{remark}{Explicit Inference Rules for Product Types}{explicit-inference-rules-for-product-types}%
    Product types have the following inference rules:
    \begin{enumerate}
        \item\label{explicit-inference-rules-for-product-types-formation}\SloganFont{Formation. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \infer2[(×-form)]{\context{\Gamma}{A\times B\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-product-types-introduction}\SloganFont{Introduction. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \infer2[(×-intro)]{\context{\Gamma}{\displaystyle\pair\oftype(A\to B)\to A\times B}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-product-types-induction}\SloganFont{Induction. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \hypo{\context{\Gamma,\,z\oftype A\times B}{P(z)\type}}%
                    \infer3[(×-ind)]{\context{\Gamma}{\displaystyle\ind_{\mathord{\times}}\oftype\left(\prod_{x\oftype A}\prod_{y\oftype B}P(x,y)\right)\to\left(\prod_{z\oftype A\times B}P(z)\right)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-product-types-computation}\SloganFont{Computation. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{A\type}}%
                    \hypo{\context{\Gamma}{B\type}}%
                    \hypo{\context{\Gamma,\,z\oftype A\times B}{P(z)\type}}%
                    \infer3[(×-comp)]{\context{\Gamma}{\displaystyle\ind_{\times}(f,\pair(x,y))\doteq f(x,y)\oftype\prod_{z\oftype A\times B}P(z)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
    \end{enumerate}
\end{remark}
\begin{definition}{Projection Functions for Product Types}{projection-functions-for-product-types}%
    Let $A$ be a type and let $B$ be a type family over $A$.
    \begin{enumerate}
        \item\label{projection-functions-for-product-types-the-first-projection-map}The \index[type-theory]{product type!first projection map}\textbf{first projection map} is the function
            \[
                \pr_{1}%
                \oftype%
                A\times B
                \to%
                A%
            \]%
            defined via induction by
            \[
                \pr_{1}(x,y)%
                \defeq%
                x.%
            \]%
        \item\label{projection-functions-for-product-types-the-second-projection-map}The \index[type-theory]{product type!second projection map}\textbf{second projection map} is the dependent function
            \[
                \pr_{2}%
                \oftype%
                A\times B
                \to%
                B%
            \]%
            defined via induction by
            \[
                \pr_{2}(x,y)%
                \defeq%
                y.%
            \]%
    \end{enumerate}
\end{definition}
\begin{proposition}{Properties of Product Types}{properties-of-product-types}%
    Let $A$ be a type, let $B$ be a type family over $A$, and let $P$ be a type family over $B$.
    \begin{enumerate}
        \item\label{properties-of-product-types-currying}\SloganFont{Currying. }There exists a function\index[type-theory]{currying}%
            %--- Begin Footnote ---%
            \footnote{%
                The function $\evpair_{\times}$ forms a converse to the induction principle for product types, which is thus also called \index[type-theory]{uncurrying}\textbf{uncurrying}.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
            \[%
                \evpair_{\times}%
                \oftype%
                [A\times B,C]%
                \to
                [A,[B,C]]%
            \]%
            defined by
            \[
                \evpair_{\times}(f)%
                \defeq%
                \llbracket x\mapsto\llbracket y\mapsto f(\pair(x,y))\rrbracket\rrbracket.%
            \]%
        %\item\label{properties-of-sigma-types-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-sigma-types}}%
    \FirstProofBox{\cref{properties-of-sigma-types-currying}: Currying}%
    There is nothing to prove.
\end{Proof}
\subsection{The Negation of a Type}\label{subsection-the-negation-of-a-type}
Let $A$ be a type.
\begin{definition}{The Negation of a Type}{the-negation-of-a-type}%
    The \index[type-theory]{negation of a type}\textbf{negation of $A$} is the type \index[notation]{A@$\neg A$}$\neg A$ defined by%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology: }A type is \index[type-theory]{type!empty}\textbf{empty} if there exists a term of type $\neg A$.
    }%
    %---  End Footnote  ---%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Notation: }We define
        \[
            \isempty(A)%
            \defeq%
            A%
            \to%
            \EmptyType.%
        \]%
        \par\vspace*{\TCBBoxCorrection}
    }%
    %---  End Footnote  ---%
    \[
        \neg A%
        \defeq%
        A\to\EmptyType.%
    \]%
\end{definition}
\begin{proposition}{Properties of Negations of Types}{properties-of-negations-of-types}%
    Let $A$ and $B$ be types.
    \begin{enumerate}
        \item\label{properties-of-negations-of-types-contrapositive}\SloganFont{Contrapositive. }There exists a function
            \[
                (A\to B)%
                \to
                (\neg B\to\neg A).%
            \]%
        %\item\label{properties-of-negations-of-types-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-negations-of-types}}%
    \FirstProofBox{\cref{properties-of-negations-of-types-contrapositive}: Contrapositive}%
    We have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \infer2[(FT)]{\context{\Gamma}{A\to B\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \infer1{\context{\Gamma}{\neg B\type}}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{A\type}}%
            \infer1[(G)]{\context{\Gamma,\,a\oftype A}{a\oftype A}}%
            \hypo{\context{\Gamma}{B\type}}%
            \infer1{\context{\Gamma}{\neg B\type}}%
            \infer1[(G)]{\context{\Gamma,\,\widetilde{b}\oftype\neg B}{\widetilde{b}\oftype\neg B}}%
            \hypo{\context{\Gamma}{A\type}}%
            \hypo{\context{\Gamma}{B\type}}%
            \infer2[(FT)]{\context{\Gamma}{A\to B\type}}%
            \infer1[(G)]{\context{\Gamma,\,f\oftype A\to B}{f\oftype A\to B}}%
            \infer2[(comp)]{\context{\Gamma,\,\widetilde{b}\oftype\neg B,\,f\oftype A\to B}{\widetilde{b}\circ f\oftype A\to\EmptyType}}%
            \infer2[(ev2)]{\context{\Gamma,\,a\oftype A,\,\widetilde{b}\oftype\neg B,\,f\oftype A\to B}{[\widetilde{b}\circ f](a)\oftype\EmptyType}}%
            \infer2[(λ)]{\context{\Gamma,\,\widetilde{b}\oftype\neg B,\,f\oftype A\to B}{\llbracket a\mapsto[\widetilde{b}\circ f](a)\rrbracket\oftype A\to\EmptyType}}%
            \infer1{\context{\Gamma,\,\widetilde{b}\oftype\neg B,\,f\oftype A\to B}{\llbracket a\mapsto[\widetilde{b}\circ f](a)\rrbracket\oftype\neg A}}%
            \infer2[(λ)]{\context{\Gamma,\,f\oftype A\to B}{\llbracket\widetilde{b}\mapsto\llbracket a\mapsto[\widetilde{b}\circ f](a)\rrbracket\rrbracket\oftype\neg B\to\neg A}}%
            \infer2[(λ)]{\context{\Gamma}{\llbracket f\mapsto\llbracket\widetilde{b}\mapsto\llbracket a\mapsto[\widetilde{b}\circ f](a)\rrbracket\rrbracket\rrbracket\oftype(A\to B)\to(\neg B\to\neg A)}}%
        \end{prooftree}%
        ,%
    \end{scalewebprooftree}%
    where we have omitted a few weakening steps. This finishes the proof.
\end{Proof}
\subsection{The Type of Bi-Implications}\label{subsection-the-type-of-bi-implications}
Let $P$ and $Q$ be types.
\begin{definition}{The Type of Bi-Implications}{the-type-of-bi-implications}%
    The \index[type-theory]{type of bi-implications}\textbf{type of bi-implications} is the type \index[notation]{PiffQ@$P\biimplications Q$}$P\biimplications Q$ defined by
    \[
        P\biimplications Q%
        \defeq%
        (P\to Q)\times(Q\to P).%
    \]%
\end{definition}
\subsection{The Type of Boolean Values}\label{subsection-the-type-of-boolean-values}
Page 36 (52)
\section{Identity Types}\label{section-martin-löf-type-theory-identity-types}
\subsection{Foundations}\label{subsection-martin-löf-type-theory-identity-types-foundations}
Let $A$ be a type and let $a\oftype A$.
\begin{definition}{Identity Types}{identity-types}%
    The \index[type-theory]{identity type}\textbf{identity type} of $A$ at $a$ is the inductive family of types \index[notation]{aequalsAx@$a\equals_{A}x$}$a\equals_{A}x$%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Notation: }Also written \index[notation]{IdA@$\Id_{A}$}$\Id_{A}$ or \index[notation]{aequalsx@$a\equals x$}$a\equals x$.%
    } %
    %---  End Footnote  ---%
    equipped with a term
    \[
        \refl_{a}%
        \oftype%
        a\equals_{A}a%
    \]%
    satisfying the following induction principle:%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology: }A term of type $a\equals_{A}x$ is called an \index[type-theory]{identification}\textbf{identification} of $a$ with $x$, or a \textbf{path} from $a$ to $x$.
    }%
    %---  End Footnote  ---%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology: }The induction principle for identity types is called \index[type-theory]{identification elimination}\textbf{identification elimination}, \index[type-theory]{identity elimination}\textbf{identity elimination} or \index[type-theory]{path induction}\textbf{path induction}.
        \par\vspace*{\TCBBoxCorrection}
    }%
    %---  End Footnote  ---%
    \begin{itemize}
        \itemstar Given a type family $P$ indexed over $x\oftype A$ and $p\oftype a\equals_{A}x$, there exists a function
            \[
                \indeq{a}%
                \oftype%
                P(a,\refl_{a})%
                \to%
                \prod_{x\oftype A}\prod_{p\oftype a\equals_{A}x}P(x,p)%
            \]%
            satisfying the computation rule
            \[
                \indeq{a}(u,a,\refl_{a})%
                \doteq%
                u.%
            \]%
    \end{itemize}
\end{definition}
\begin{remark}{Explicit Inference Rules for Identity Types}{explicit-inference-rules-for-identity-types}%
    The identity type of $A$ at $a$ has the following inference rules:
    \begin{enumerate}
        \item\label{explicit-inference-rules-for-identity-types-formation}\SloganFont{Formation. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \infer1[(id-form)]{\context{\Gamma,\,x\oftype A}{a\equals_{A}x\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-identity-types-introduction}\SloganFont{Introduction. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \infer1[(id-intro)]{\context{\Gamma}{\refl_{a}\oftype a\equals_{A}a}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-identity-types-induction}\SloganFont{Induction. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,p\oftype a\equals_{A}x}{P(x,p)\type}}%
                    \infer2[(id-ind)]{\context{\Gamma}{\displaystyle\indeq{a}\oftype P(a,\refl_{a})\to\prod_{x\oftype A}\prod_{p\oftype a\equals_{A}x}P(x,p)}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{explicit-inference-rules-for-identity-types-computation}\SloganFont{Computation. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \hypo{\context{\Gamma,\,x\oftype A,\,p\oftype a\equals_{A}x}{P(x,p)\type}}%
                    \infer2[(id-comp)]{\context{\Gamma,\,u\oftype P(a,\refl_{a})}{\indeq{a}(u,a,\refl_{a})\doteq u\oftype P(a,\refl_{a})}}%
                \end{prooftree}
                .%
            \end{webprooftree}%
        %\item\label{explicit-inference-rules-for-identity-types-}\SloganFont{. }
    \end{enumerate}
\end{remark}
\begin{notation}{\say{Inequality} Types}{inequality-types}%
    We write \index[notation]{xnotequalsAy@$x\nequals_{A}y$}$x\nequals_{A}y$ for the type defined by
    \[
        x\nequals_{A}y%
        \defeq%
        (x\equals_{A}y)%
        \to%
        \EmptyType.%
    \]%
\end{notation}
\begin{proposition}{Properties of Identity Types}{properties-of-identity-types}%
    Let $A$ be a type and let $a\oftype A$.
    \begin{enumerate}
        \item\label{properties-of-identity-types-a-second-identity-formation-rule}\SloganFont{A Second Identity Formation Rule. }We have
            \begin{webprooftree}%
                \begin{prooftree}%
                    \hypo{\context{\Gamma}{a\oftype A}}%
                    \infer1[(id-form')]{\context{\Gamma,\,x\oftype A}{x\equals_{A}a\type}}%
                \end{prooftree}%
                .%
            \end{webprooftree}%
        \item\label{properties-of-identity-types-concatenation}\SloganFont{Concatenation. }There exists a dependent function\index[notation]{concat@$\concat$}%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Further Notation: }We write \index[notation]{qp@$q\ccirc p$}$q\ccirc p$ for $\concat_{x,y,z}(q,p)$.
            }%
            %---  End Footnote  ---%
            \[
                \concat%
                \oftype%
                \prod_{x,y,z\oftype A}[(y\equals_{A}z)\times(x\equals_{A}y),x\equals_{A}z]%
                %\left((y\equals_{A}z)\to(x\equals_{A}y\to x\equals_{A}z)\right)%
            \]%
            taking terms $p\oftype x\equals_{A}y$ and $q\oftype y\equals_{A}z$ and producing a term
            \[
                \concat_{x,y,z}(q,p)%
                \oftype%
                x\equals_{A}z.%
            \]%
        \item\label{properties-of-identity-types-associativity}\SloganFont{Associativity. }There exists a dependent function\index[notation]{assoc@$\assoc$}
            \[
                \assoc%
                \oftype%
                \prod_{\substack{w\oftype A\\x\oftype A\\y\oftype A\\z\oftype A}}%
                \prod_{\substack{p\oftype w\equals_{A}x\\q\oftype x\equals_{A}y\\r\oftype y\equals_{A}z}}%
                (r\ccirc q)\ccirc p%
                \equals_{w\equals_{a}z}%
                r\ccirc(q\ccirc p).%
            \]%
        \item\label{properties-of-identity-types-left-unitality}\SloganFont{Left Unitality. }We have a dependent function
            \[
                \leftunit%
                \oftype%
                \prod_{x,y\oftype A}\prod_{p\oftype x\equals_{A}y}\refl_{y}\ccirc p\equals_{x\equals_{A}y}p.%
            \]%
        \item\label{properties-of-identity-types-right-unitality}\SloganFont{Right Unitality. }We have a dependent function
            \[
                \rightunit%
                \oftype%
                \prod_{x,y\oftype A}\prod_{p\oftype x\equals_{A}y}p\ccirc\refl_{x}\equals_{x\equals_{A}y}p.%
            \]%
        \item\label{properties-of-identity-types-inversion}\SloganFont{Inversion. }There exists a dependent function\index[notation]{inv@$\inv$}%
            %--- Begin Footnote ---%
            \footnote{%
                \SloganFont{Further Notation: }We write \index[notation]{pminusone@$p^{-1}$}$p^{-1}$ for $\inv_{x,y}(p)$.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
            \[
                \inv%
                \oftype%
                \prod_{x,y\oftype A}(x\equals_{A}y\to y\equals_{A}x).%
            \]%
        \item\label{properties-of-identity-types-left-invertibility}\SloganFont{Left Invertibility. }There exists a dependent function
            \[
                \leftinv%
                \oftype%
                \prod_{x,y\oftype A}\prod_{p\oftype x\equals_{A}y}p^{-1}\ccirc p\equals_{y\equals_{A}y}\refl_{y}.%
            \]%
        \item\label{properties-of-identity-types-right-invertibility}\SloganFont{Right Invertibility. }There exists a dependent function
            \[
                \rightinv%
                \oftype%
                \prod_{x,y\oftype A}\prod_{p\oftype x\equals_{A}y}p^{-1}\ccirc p\equals_{x\equals_{A}x}\refl_{x}.%
            \]%
        \item\label{properties-of-identity-types-uniqueness-of-refl}\SloganFont{Uniqueness of $\refl$. }The type%
            %--- Begin Footnote ---%
            \footnote{%
                The terms of $\sum_{x\oftype A}a\equals_{A}x$ may be thought as pairs $(x,p)$ with $x\oftype A$ and $p\oftype a\equals_{A}x$.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
            \[
                \sum_{x\oftype A}a\equals_{A}x%
            \]%
            is contractible, being generated by $(a,\refl_{a})$.
        %\item\label{properties-of-identity-types-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-identity-types}}%
    \FirstProofBox{\cref{properties-of-identity-types-a-second-identity-formation-rule}: A Second Identity Formation Rule}%
    We have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{a\oftype A}}%
            \hypo{\context{\Gamma}{a\oftype A}}%
            \infer1{\context{\Gamma}{A\type}}%
            \infer1[(G)]{\context{\Gamma,\,x\oftype A}{x\oftype A}}%
            \infer1[(id-form)]{\context{\Gamma,\,x\oftype A,\,y\oftype A}{x\equals_{A}y\type}}%
            \infer2[(S)]{\context{\Gamma,\,y\oftype A}{a\equals_{A}y\type}}%
            \infer1[(CV)]{\context{\Gamma,\,x\oftype A}{a\equals_{A}x\type}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    This finishes the proof.

    \ProofBox{\cref{properties-of-identity-types-concatenation}: Concatenation}%
    We start by first constructing a function
    \[
        \concat'_{z}%
        \oftype%
        \prod_{y\oftype A}y\equals_{A}z%
        \to%
        \prod_{x\oftype A}(x\equals_{A}y\to x\equals_{A}z)%
    \]%
    given $z\oftype A$. For this, we first construct a dependent function
    \[
        \concat'_{x,z,z}(\refl_{z})%
        \oftype%
        \prod_{z\oftype A}(x\equals_{A}z\to x\equals_{A}z).%
    \]%
    For that, we have
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{z\oftype A}}%
            \infer1[(id-form')]{\context{\Gamma,\,x\oftype A}{x\equals_{A}z\type}}%
            \infer1[(id)]{\context{\Gamma,\,x\oftype A}{\sfid_{x\equals_{A}z}\oftype x\equals_{A}z\to x\equals_{A}z}}%
            \infer1[(λ)]{\context{\Gamma}{\displaystyle\llbracket x\mapsto\sfid_{x\equals_{A}z}\rrbracket\oftype\prod_{x\oftype A}x\equals_{A}z\to x\equals_{A}z}}%
            \infer1{\context{\Gamma}{\displaystyle\concat'_{x,z,z}(\refl_{z})\doteq\llbracket x\mapsto\sfid_{x\equals_{A}z}\rrbracket\oftype\prod_{x\oftype A}x\equals_{A}z\to x\equals_{A}z}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    Having $\concat'_{x,z,z}(\refl_{z})$ in hand, we may use path induction to obtain $\concat'_{z}$:
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{z\oftype A}}%
            \hypo{\context{\Gamma,\,y\oftype A,\,q\oftype y\equals_{A}z}{\displaystyle\prod_{x\oftype A}(x\equals_{A}y\to x\equals_{A}z)\type}}%
            \infer2[(id-ind)]{\context{\Gamma}{\displaystyle\indeq{z}\oftype\prod_{x\oftype A}(x\equals_{A}y\to x\equals_{A}z)\to\prod_{y\oftype A}\prod_{q\oftype y\equals_{A}z}\prod_{x\oftype A}(x\equals_{A}y\to x\equals_{A}z)}}%
            \infer1{\context{\Gamma}{\displaystyle\concat'_{z}\doteq\indeq{z}\left(\concat'_{x,z,z}(\refl_{z})\right)\oftype\prod_{y\oftype A}\prod_{q\oftype y\equals_{A}z}\prod_{x\oftype A}(x\equals_{A}y\to x\equals_{A}z)}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    We then define a function $\concat'$ via λ-abstraction:
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,z\oftype A}{\displaystyle\concat'_{z}\oftype\prod_{y\oftype A}\prod_{q\oftype y\equals_{A}z}\prod_{x\oftype A}(x\equals_{A}y\to x\equals_{A}z)}}%
            \infer1[(λ)]{\context{\Gamma}{\displaystyle\llbracket z\mapsto\concat'_{z}\rrbracket\oftype\prod_{z\oftype A}\prod_{y\oftype A}\prod_{q\oftype y\equals_{A}z}\prod_{x\oftype A}(x\equals_{A}y\to x\equals_{A}z)}}%
            \infer1{\context{\Gamma}{\displaystyle\llbracket z\mapsto\concat'_{z}\rrbracket\oftype\prod_{z\oftype A}\prod_{y\oftype A}\prod_{q\oftype y\equals_{A}z}\prod_{x\oftype A}\prod_{p\oftype x\equals_{A}y}x\equals_{A}z}}%
            \infer1[(swap)]{\context{\Gamma}{\displaystyle\llbracket z\mapsto\concat'_{z}\rrbracket\oftype\prod_{x\oftype A}\prod_{y\oftype A}\prod_{z\oftype A}\prod_{q\oftype y\equals_{A}z}\prod_{p\oftype x\equals_{A}y}x\equals_{A}z}}%
            \infer1{\context{\Gamma}{\displaystyle\llbracket z\mapsto\sigma\circ\concat'_{x}\rrbracket\oftype\prod_{x,y,z\oftype A}(y\equals_{A}z)\to(x\equals_{A}y\to x\equals_{A}z)}}%
            \infer1{\context{\Gamma}{\displaystyle\concat'\doteq\llbracket z\mapsto\sigma\circ\concat'_{x}\rrbracket\oftype\prod_{x,y,z\oftype A}(y\equals_{A}z)\to(x\equals_{A}y\to x\equals_{A}z)}}%
        \end{prooftree}%
        .
    \end{webprooftree}%
    Finally, we may obtain $\concat$ from $\concat'$ via \cref{properties-of-product-types-currying} of \cref{properties-of-product-types}.

    \ProofBox{\cref{properties-of-identity-types-associativity}: Associativity}%
    We start by first constructing the term
    \[
        \assoc_{w,w,y,z}(r,q,\refl_{w})%
        \oftype%
        \prod_{y\oftype A}%
        \prod_{q\oftype w\equals_{A}y}%
        \prod_{z\oftype A}%
        \prod_{r\oftype y\equals_{A}z}%
        (r\ccirc q)\ccirc\refl_{w}%
        \equals_{w\equals_{A}y}%
        r\ccirc(q\ccirc\refl_{w}).%
    \]%
    For this, notice that we have judgemental equalities of the form $q\ccirc\refl_{w}\doteq q$, so we have
    \begin{align*}
        (r\ccirc q)\ccirc\refl_{w} &\doteq r\ccirc q,\\
        r\ccirc(q\ccirc\refl_{w})  &\doteq r\ccirc q.
    \end{align*}
    As a result, we may define
    \[
        \assoc_{w,w,y,z}(r,q,\refl_{w})%
        \defeq%
        \refl_{q\ccirc r}.% 
    \]%
    With the construction of $\assoc_{w,w,y,z}(r,q,\refl_{w})$ at hand, we may use path induction to obtain $\assoc_{w,x,y,z}(r,q,p)$:
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{w\oftype A}}%
            \hypo{\context{\Gamma,\,x\oftype A,\,p\oftype w\equals_{A}x}{\displaystyle\prod_{y\oftype A}\prod_{q\oftype w\equals_{A}y}\prod_{z\oftype A}\prod_{r\oftype y\equals_{A}z}(r\ccirc q)\ccirc p\equals_{w\equals_{A}x}r\ccirc(q\ccirc p)\type}}%
            \infer2[(id-ind)]{\context{\Gamma}{\displaystyle\indeq{w}\oftype\prod_{y\oftype A}\prod_{q\oftype w\equals_{A}y}\prod_{z\oftype A}\prod_{r\oftype y\equals_{A}z}(r\ccirc q)\ccirc\refl_{w}\equals_{w\equals_{A}x}r\ccirc(q\ccirc\refl_{w})\to\prod_{x\oftype A}\prod_{p\oftype w\equals_{A}x}\prod_{y\oftype A}\prod_{q\oftype x\equals_{A}y}\prod_{z\oftype A}\prod_{r\oftype y\equals_{A}z}(r\ccirc q)\ccirc p\equals_{w\equals_{A}x}r\ccirc(q\ccirc p)}}%
            \infer1{\context{\Gamma}{\displaystyle\indeq{x}(r,q,\refl_{w})\oftype\prod_{x\oftype A}\prod_{p\oftype w\equals_{A}x}\prod_{y\oftype A}\prod_{q\oftype x\equals_{A}y}\prod_{z\oftype A}\prod_{r\oftype y\equals_{A}z}(r\ccirc q)\ccirc p\equals_{w\equals_{A}x}r\ccirc(q\ccirc p)}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    Finally, we define $\assoc_{w,x,y,z}$ via λ-abstraction:
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,w\oftype A}{\displaystyle\assoc_{w,x,y,z}(r,q,\refl_{w})\oftype\prod_{x\oftype A}\prod_{p\oftype w\equals_{A}x}\prod_{y\oftype A}\prod_{q\oftype x\equals_{A}y}\prod_{z\oftype A}\prod_{r\oftype y\equals_{A}z}(r\ccirc q)\ccirc p\equals_{w\equals_{A}x}r\ccirc(q\ccirc p)}}%
            \infer1[(λ)]{\context{\Gamma}{\displaystyle\llbracket w\mapsto\assoc_{w,x,y,z}(r,q,\refl_{x})\rrbracket\oftype\prod_{w\oftype A}\prod_{x\oftype A}\prod_{p\oftype w\equals_{A}x}\prod_{y\oftype A}\prod_{q\oftype x\equals_{A}y}\prod_{z\oftype A}\prod_{r\oftype y\equals_{A}z}(r\ccirc q)\ccirc p\equals_{w\equals_{A}x}r\ccirc(q\ccirc p)}}%
            \infer1[(swap)]{\context{\Gamma}{\displaystyle\llbracket w\mapsto\sigma\circ\assoc_{w,x,y,z}(r,q,\refl_{x})\rrbracket\oftype\prod_{w\oftype A}\prod_{x\oftype A}\prod_{y\oftype A}\prod_{z\oftype A}\prod_{p\oftype w\equals_{A}x}\prod_{q\oftype x\equals_{A}y}\prod_{r\oftype y\equals_{A}z}(r\ccirc q)\ccirc p\equals_{w\equals_{A}x}r\ccirc(q\ccirc p)}}%
            \infer1{\context{\Gamma}{\displaystyle\llbracket w\mapsto\sigma\circ\assoc_{w,x,y,z}(r,q,\refl_{x})\rrbracket\oftype\prod_{\substack{w\oftype A\\x\oftype A\\y\oftype A\\z\oftype A}}\prod_{\substack{p\oftype w\equals_{A}x\\q\oftype x\equals_{A}y\\r\oftype y\equals_{A}z}}(r\ccirc q)\ccirc p\equals_{w\equals_{A}x}r\ccirc(q\ccirc p)}}%
        \end{prooftree}%
        .
    \end{scalewebprooftree}%
    This finishes the construction of $\assoc$.

    \ProofBox{\cref{properties-of-identity-types-left-unitality}: Left Unitality}%
    First, we construct
    \[
        \leftunit_{x,x}(\refl_{x})%
        \oftype%
        \refl_{x}\ccirc\refl_{x}%
        \equals_{x\equals_{A}x}%
        \refl_{x}.%
    \]%
    Since $\refl_{x}\ccirc\refl_{x}$ and $\refl_{x}$ are judgementally equal, we may define
    \[
        \leftunit_{x,x}(\refl_{x})%
        \defeq%
        \refl_{\refl_{x}}.%
    \]%
    By path induction, we then have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,x\oftype A}{\leftunit_{x,x}(\refl_{x})\oftype\refl_{x}\ccirc\refl_{x}\equals_{x\equals_{A}x}\refl_{x}}}%
            \hypo{\context{\Gamma}{x\oftype A}}%
            \hypo{\context{\Gamma,\,y\oftype A,\,p\oftype x\equals_{A}y}{p\ccirc\refl_{x}\equals_{x\equals_{A}y}p\type}}%
            \infer2[(id-ind)]{\context{\Gamma}{\displaystyle\indeq{x}\oftype\refl_{x}\ccirc\refl_{x}\equals_{x\equals_{A}x}\refl_{x}\to\prod_{y\oftype A}\prod_{p\oftype x\equals_{A}y}p\ccirc\refl_{x}\equals_{x\equals_{A}y}p}}%
            \infer2[(ev2)]{\context{\Gamma,\,x\oftype A}{\displaystyle\indeq{x}(\leftunit_{x,x}(\refl_{x}))\oftype\prod_{y\oftype A}\prod_{p\oftype x\equals_{A}y}p\ccirc\refl_{x}\equals_{x\equals_{A}y}p}}%
            \infer1[(λ)]{\context{\Gamma}{\displaystyle\llbracket x\mapsto\indeq{x}(\leftunit_{x,x}(\refl_{x}))\rrbracket\oftype\prod_{x\oftype A}\prod_{y\oftype A}\prod_{p\oftype x\equals_{A}y}p\ccirc\refl_{x}\equals_{x\equals_{A}y}p}}%
            \infer1{\context{\Gamma}{\displaystyle\leftunit\doteq\llbracket x\mapsto\indeq{x}(\leftunit_{x,x}(\refl_{x}))\rrbracket\oftype\prod_{x,y\oftype A}\prod_{p\oftype x\equals_{A}y}p\ccirc\refl_{x}\equals_{x\equals_{A}y}p}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the construction of $\leftunit$.

    \ProofBox{\cref{properties-of-identity-types-right-unitality}: Right Unitality}%
    First, we construct
    \[
        \rightunit_{x,x}(\refl_{x})%
        \oftype%
        \refl_{x}\ccirc\refl_{x}%
        \equals_{x\equals_{A}x}%
        \refl_{x}.%
    \]%
    Since $\refl_{x}\ccirc\refl_{x}$ and $\refl_{x}$ are judgementally equal, we may define
    \[
        \rightunit_{x,x}(\refl_{x})%
        \defeq%
        \refl_{\refl_{x}}.%
    \]%
    By path induction, we then have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,x\oftype A}{\rightunit_{x,x}(\refl_{x})\oftype\refl_{x}\ccirc\refl_{x}\equals_{x\equals_{A}x}\refl_{x}}}%
            \hypo{\context{\Gamma}{x\oftype A}}%
            \hypo{\context{\Gamma,\,y\oftype A,\,p\oftype x\equals_{A}y}{\refl_{y}\ccirc p\equals_{x\equals_{A}y}p\type}}%
            \infer2[(id-ind)]{\context{\Gamma}{\displaystyle\indeq{x}\oftype\refl_{x}\ccirc\refl_{x}\equals_{x\equals_{A}x}\refl_{x}\to\prod_{y\oftype A}\prod_{p\oftype x\equals_{A}y}\refl_{y}\ccirc p\equals_{x\equals_{A}y}p}}%
            \infer2[(ev2)]{\context{\Gamma,\,x\oftype A}{\displaystyle\indeq{x}(\rightunit_{x,x}(\refl_{x}))\oftype\prod_{y\oftype A}\prod_{p\oftype x\equals_{A}y}\refl_{y}\ccirc p\equals_{x\equals_{A}y}p}}%
            \infer1[(λ)]{\context{\Gamma}{\displaystyle\llbracket x\mapsto\indeq{x}(\rightunit_{x,x}(\refl_{x}))\rrbracket\oftype\prod_{x\oftype A}\prod_{y\oftype A}\prod_{p\oftype x\equals_{A}y}\refl_{y}\ccirc p\equals_{x\equals_{A}y}p}}%
            \infer1{\context{\Gamma}{\displaystyle\rightunit\doteq\llbracket x\mapsto\indeq{x}(\rightunit_{x,x}(\refl_{x}))\rrbracket\oftype\prod_{x,y\oftype A}\prod_{p\oftype x\equals_{A}y}\refl_{y}\ccirc p\equals_{x\equals_{A}y}p}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the construction of $\rightunit$.

    \ProofBox{\cref{properties-of-identity-types-inversion}: Inversion}%
    We have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma}{x\oftype A}}%
            \infer1[(id-intro)]{\context{\Gamma}{\refl_{x}\oftype x\equals_{A}x}}%
            \hypo{\context{\Gamma}{x\oftype A}}%
            \hypo{\context{\Gamma,\,y\oftype A,\,p\oftype x\equals_{A}y}{y\equals_{A}x\type}}%
            \infer2[(id-ind)]{\context{\Gamma}{\displaystyle\indeq{x}\oftype x\equals_{A}x\to\prod_{y\oftype A}(x\equals_{A}y\to y\equals_{A}x)}}%
            \infer2[(ev2)]{\context{\Gamma}{\displaystyle\indeq{x}(\refl_{x})\oftype\prod_{y\oftype A}(x\equals_{A}y\to y\equals_{A}x)}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    We then define $\inv$ via λ-abstraction
    \begin{webprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,x\oftype A}{\displaystyle\indeq{x}(\refl_{x})\oftype\prod_{y\oftype A}(x\equals_{A}y\to y\equals_{A}x)}}%
            \infer1[(λ)]{\context{\Gamma}{\displaystyle\llbracket x\mapsto\indeq{x}(\refl_{x})\rrbracket\oftype\prod_{x\oftype A}\prod_{y\oftype A}(x\equals_{A}y\to y\equals_{A}x)}}%
            \infer1{\context{\Gamma}{\displaystyle\inv\doteq\llbracket x\mapsto\indeq{x}(\refl_{x})\rrbracket\oftype\prod_{x,y\oftype A}(x\equals_{A}y\to y\equals_{A}x)}}%
        \end{prooftree}%
        .%
    \end{webprooftree}%
    This finishes the construction of $\inv$.

    \ProofBox{\cref{properties-of-identity-types-left-invertibility}: Left Invertibility}%
    First, notice that we have a judgemental equality of the form $\refl^{-1}_{y}\doteq\refl_{y}$, and thus a judgemental equality of the form
    \[
        \refl^{-1}_{y}\cdot\refl_{y}%
        \doteq%
        \refl_{y}.%
    \]%
    This allows us to define
    \[
        \leftinv_{y,y}(\refl_{y})%
        \defeq%
        \refl_{\refl_{y}}.%
    \]%
    By path induction, we then have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,y\oftype A}{\leftinv_{y,y}\left(\refl_{y}\right)\oftype\refl^{-1}_{y}\ccirc\refl_{y}\equals_{y\equals_{A}y}\refl_{y}}}%
            \hypo{\context{\Gamma}{y\oftype A}}%
            \hypo{\context{\Gamma,\,x\oftype A,\,p\oftype x\equals_{A}y}{p^{-1}\ccirc p\equals_{y\equals_{A}y}\refl_{y}\type}}%
            \infer2[(id-ind)]{\context{\Gamma}{\displaystyle\indeq{y}\oftype\refl^{-1}_{y}\ccirc\refl_{y}\equals_{y\equals_{A}y}\refl_{y}\to\prod_{x\oftype A}\prod_{p\oftype x\equals_{A}y}p^{-1}\ccirc p\equals_{y\equals_{A}y}\refl_{y}}}%
            \infer2[(ev2)]{\context{\Gamma,\,y\oftype A}{\displaystyle\indeq{y}\left(\leftinv_{y,y}\left(\refl_{y}\right)\right)\oftype\prod_{x\oftype A}\prod_{p\oftype x\equals_{A}y}p^{-1}\ccirc p\equals_{y\equals_{A}y}\refl_{y}}}%
            \infer1[(λ)]{\context{\Gamma}{\displaystyle\leftllbracket y\mapsto\indeq{y}(\leftinv_{y,y}(\refl_{y}))\rightrrbracket\oftype\prod_{y\oftype A}\oftype\prod_{x\oftype A}\prod_{p\oftype x\equals_{A}y}p^{-1}\ccirc p\equals_{y\equals_{A}y}\refl_{y}}}%
            \infer1[(swap)]{\context{\Gamma}{\displaystyle\leftllbracket y\mapsto\indeq{y}(\leftinv_{y,y}(\refl_{y}))\rightrrbracket\oftype\prod_{x\oftype A}\prod_{y\oftype A}\prod_{p\oftype x\equals_{A}y}p^{-1}\ccirc p\equals_{y\equals_{A}y}\refl_{y}}}%
            \infer1{\context{\Gamma}{\displaystyle\leftinv\doteq\leftllbracket y\mapsto\indeq{y}(\leftinv_{y,y}(\refl_{y}))\rightrrbracket\oftype\prod_{x,y\oftype A}\prod_{p\oftype x\equals_{A}y}p^{-1}\ccirc p\equals_{y\equals_{A}y}\refl_{y}}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the construction of $\leftinv$.

    \ProofBox{\cref{properties-of-identity-types-right-invertibility}: Right Invertibility}%
    First, notice that we have a judgemental equality of the form $\refl^{-1}_{x}\doteq\refl_{x}$, and thus a judgemental equality of the form
    \[
        \refl_{x}\cdot\refl^{-1}_{x}%
        \doteq%
        \refl_{x}.%
    \]%
    This allows us to define
    \[
        \rightinv_{x,x}\left(\refl_{x}\right)%
        \defeq%
        \refl_{\refl_{x}}.%
    \]%
    By path induction, we then have
    \begin{scalewebprooftree}%
        \begin{prooftree}%
            \hypo{\context{\Gamma,\,x\oftype A}{\rightinv_{x,x}\left(\refl_{x}\right)\oftype\refl^{-1}_{x}\ccirc\refl_{x}\equals_{x\equals_{A}x}\refl_{x}}}%
            \hypo{\context{\Gamma}{x\oftype A}}%
            \hypo{\context{\Gamma,\,y\oftype A,\,p\oftype x\equals_{A}y}{p\ccirc p^{-1}\equals_{x\equals_{A}x}\refl_{x}\type}}%
            \infer2[(id-ind)]{\context{\Gamma}{\displaystyle\indeq{x}\oftype\refl^{-1}_{x}\ccirc\refl_{x}\equals_{x\equals_{A}x}\refl_{x}\to\prod_{y\oftype A}\prod_{p\oftype x\equals_{A}y}p\ccirc p^{-1}\equals_{x\equals_{A}x}\refl_{x}}}%
            \infer2[(ev2)]{\context{\Gamma,\,x\oftype A}{\displaystyle\indeq{x}(\rightinv_{x,x}\left(\refl_{x}\right))\oftype\prod_{y\oftype A}\prod_{p\oftype x\equals_{A}y}p\ccirc p^{-1}\equals_{x\equals_{A}x}\refl_{x}}}%
            \infer1[(λ)]{\context{\Gamma}{\displaystyle\leftllbracket x\mapsto\indeq{x}(\rightinv_{x,x}\left(\refl_{x}\right))\rightrrbracket\oftype\prod_{x\oftype A}\oftype\prod_{y\oftype A}\prod_{p\oftype x\equals_{A}y}p\ccirc p^{-1}\equals_{x\equals_{A}x}\refl_{x}}}%
            \infer1{\context{\Gamma}{\displaystyle\rightinv\doteq\leftllbracket x\mapsto\indeq{x}(\rightinv_{x,x}\left(\refl_{x})\right)\rightrrbracket\oftype\prod_{x,y\oftype A}\prod_{p\oftype x\equals_{A}y}p\ccirc p^{-1}\equals_{x\equals_{A}x}\refl_{x}}}%
        \end{prooftree}%
        .%
    \end{scalewebprooftree}%
    This finishes the construction of $\rightinv$.

    \ProofBox{\cref{properties-of-identity-types-uniqueness-of-refl}: Uniqueness of $\refl$}%
    We need to show that, for each $y\oftype\sum_{x\oftype A}a\equals_{A}x$, the type
    \[
        (a,\refl_{a})%
        \subequals_{\scriptdisplaystyle{\sum_{x\oftype A}a\equals_{A}x}}%
        y%
    \]%
    is inhabited. By $\Sigma$-induction, it suffices to construct a term of type
    \[
        (a,\refl_{a})%
        \subequals_{\scriptdisplaystyle{\sum_{x\oftype A}a\equals_{A}x}}%
        (x,p)%
    \]%
    for each $x\oftype A$ and each $p\oftype a\equals_{A}x$. By path induction, it then suffices to construct a term of type
    \[
        (a,\refl_{a})%
        \subequals_{\scriptdisplaystyle{\sum_{x\oftype A}a\equals_{A}x}}%
        (a,\refl_{a}).%
    \]%
    For this, we use $\refl_{(a,\refl_{a})}$.
\end{Proof}
\subsection{The Action on Identification of Functions}\label{the-action-on-identification-of-functions}
Let $f\oftype A\to B$ be a function.
\begin{definition}{The Action on Identification of Functions}{action-on-identification-of-functions}%
    The \index[type-theory]{action on identification of functions}\textbf{action on identifications}%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology: }Also called the \index[type-theory]{action on paths}\textbf{action on paths} of $f$.
        \par\vspace*{\TCBBoxCorrection}
    } %
    %---  End Footnote  ---%
    of $f$ is the function
    \[
        \ap_{f}%
        \oftype%
        \prod_{{\color{OIblue}x,y\oftype A}}{\color{OIblue}x\equals_{A}y}\mathbin{\color{OIvermillion}{\to}}{\color{OIblue}f(x)\equals_{B}f(y)}%
    \]%
    defined via pattern-matching by
    \[
        \ap_{f}(\refl_{x})%
        \defeq%
        \refl_{f(x)}.%
    \]%
\end{definition}
\begin{proposition}{Properties of the Action on Identification of Functions}{properties-of-the-action-on-identification-of-functions}%
    Let $f\oftype A\to B$ and $g\oftype B\to C$ be functions.
    \begin{enumerate}
        \item\label{properties-of-the-action-on-identification-of-functions-interaction-with-identities}\SloganFont{Interaction With Identities. }There exists a dependent function
            \[
                \apid_{A}%
                \oftype%
                \prod_{x,y\oftype A}%
                \prod_{p\oftype x\equals_{A}y}%
                p\equals_{x\equals_{A}y}\ap_{\sfid_{A}}(p)%
            \]%
            defined via pattern-matching by
            \[
                \apid_{A}(\refl_{x})%
                \defeq%
                \refl_{\refl_{x}}.%
            \]%
        \item\label{properties-of-the-action-on-identification-of-functions-interaction-with-composition}\SloganFont{Interaction With Composition. }There exists a dependent function
            \[
                \apcomp_{g,f}%
                \oftype%
                \prod_{x,y\oftype A}%
                \prod_{p\oftype x\equals_{A}y}%
                \ap_{g}(\ap_{f}(p))%
                \equals_{g(f(x))\equals_{A}g(f(y))}%
                \ap_{g\circ f}(p)%
            \]%
            defined via pattern-matching by
            \[
                \apcomp_{g,f}(\refl_{x})%
                \defeq%
                \ap_{g}(\ap_{f}(\refl_{g(f(x))})).%
            \]%
        \item\label{properties-of-the-action-on-identification-of-functions-interaction-with-reflexivity}\SloganFont{Interaction With Reflexivity. }There exists a dependent function
            \[
                \aprefl_{f}%
                \oftype%
                \prod_{x,y\oftype A}%
                \prod_{p\oftype x\equals_{A}y}%
                \ap_{f}(\refl_{x})%
                \equals_{f(x)\equals_{A}f(y)}%
                \refl_{f(x)}%
            \]%
            defined via pattern-matching by
            \[
                \aprefl_{f}(\refl_{x})%
                \defeq%
                \refl_{\refl_{f(x)}}.%
            \]%
        \item\label{properties-of-the-action-on-identification-of-functions-interaction-with-inversion}\SloganFont{Interaction With Inversion. }There exists a dependent function
            \[
                \apinv_{f}%
                \oftype%
                \prod_{x,y\oftype A}%
                \prod_{p\oftype x\equals_{A}y}%
                \ap_{f}\pig(p^{-1}\pig)%
                \equals_{f(x)\equals_{A}f(y)}%
                \ap_{f}(p)^{-1}%
            \]%
            defined via path induction by
            \[
                \apinv_{f}(\refl_{x})%
                \defeq%
                \refl_{\ap_{f}(\refl_{x})}.%
            \]%
        \item\label{properties-of-the-action-on-identification-of-functions-interaction-with-concatenation}\SloganFont{Interaction With Concatenation. }There exists a dependent function
            \[
                \apconcat_{f}%
                \oftype%
                \prod_{x,y,z\oftype A}%
                \prod_{\substack{p\oftype x\equals_{A}y\\q\oftype y\equals_{A}z}}%
                \ap_{f}(q,p)%
                \equals_{f(x)\equals_{A}f(y)}%
                \ap_{f}(q)\ccirc\ap_{f}(p)%
            \]%
            defined via path induction by
            \[
                \apconcat_{f}(q,\refl_{x})%
                \defeq%
                \refl_{\ap_{f}(q)}.%
            \]%
        %\item\label{properties-of-the-action-on-identification-of-functions-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-the-action-on-identification-of-functions}}%
    \FirstProofBox{\cref{properties-of-the-action-on-identification-of-functions-interaction-with-identities}: Interaction With Identities}%
    There is nothing to prove.

    \ProofBox{\cref{properties-of-the-action-on-identification-of-functions-interaction-with-composition}: Interaction With Composition}%
    There is nothing to prove.

    \ProofBox{\cref{properties-of-the-action-on-identification-of-functions-interaction-with-reflexivity}: Interaction With Reflexivity}%
    There is nothing to prove.

    \ProofBox{\cref{properties-of-the-action-on-identification-of-functions-interaction-with-inversion}: Interaction With Inversion}%
    Omitted.

    \ProofBox{\cref{properties-of-the-action-on-identification-of-functions-interaction-with-concatenation}: Interaction With Concatenation}%
    Omitted.
\end{Proof}
\subsection{Transport}\label{subsection-martin-löf-type-theory-transport}
Let $A$ be a type and let $B$ be a type family indexed over $x\oftype A$.
\begin{definition}{The Transport Operation}{the-transport-operation}%
    The \index[type-theory]{transport operation}\textbf{transport operation} of $B$ is the function
    \[
        \sftr_{B}%
        \oftype%
        \prod_{x,y\oftype A}%
        \left(%
            (x\equals_{A}y)%
            \to%
            (B(x)\to B(y))%
        \right)%
    \]%
    defined via pattern-matching by
    \[
        \sftr_{B}(\refl_{x})%
        \defeq%
        \sfid_{B(x)}.%
    \]
\end{definition}
\subsection{The Action on Identification of Dependent Functions}\label{the-action-on-identification-of-dependent-functions}
Let $f\oftype\prod_{x\oftype A}B(x)$ be a dependent function.
\begin{definition}{The Action on Identification of Dependent Functions}{action-on-identification-of-dependent-functions}%
    The \index[type-theory]{action on identification of dependent functions}\textbf{action on identifications}%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology: }Also called the \index[type-theory]{action on paths}\textbf{action on paths} of $f$.
        \par\vspace*{\TCBBoxCorrection}
    } %
    %---  End Footnote  ---%
    of $f$ is the function
    \[
        \apd_{f}%
        \oftype%
        \prod_{x,y\oftype A}\left((x\equals_{A}y)\to(\sftr_{B}(p,f(x))\equals_{B(y)}f(y))\right)%
    \]%
    defined via pattern-matching by
    \[
        \apd_{f}(\refl_{x})%
        \defeq%
        \refl_{f(x)}.%
    \]%
\end{definition}
\section{Universes}\label{section-universes}
\subsection{Foundations}\label{subsection-universes-foundations}
\begin{definition}{Universes}{universes}%
    A \index[type-theory]{universe}\textbf{universe} is a pair $(\CatFont{U},\CatFont{T})$ consisting of:
    \begin{itemize}
        \item\SloganFont{The Universe. }A type $\CatFont{U}$;
        \item\SloganFont{The Universal Type Family. }A type family $\CatFont{T}$ over $\CatFont{U}$;
    \end{itemize}
    satisfying the following conditions:%
    %--- Begin Footnote ---%
    \footnote{%
        \SloganFont{Further Terminology: }We say that $\CatFont{U}$ \index[type-theory]{universe!containment of terms}\textbf{contains} a type $A$ if $\CatFont{U}$ has a term $\widecheck{A}$ such that the judgement
        \[
            \CatFont{T}\pig(\widecheck{A}\pig)%
            \doteq%
            A%
            \type
        \]%
        holds.
        \par\vspace*{\TCBBoxCorrection}
    }%
    %---  End Footnote  ---%
    \begin{enumerate}
        \item\label{universes-closure-under-dependent-products}\SloganFont{Closure Under Dependent Products. }There exists a function
            \[
                \widecheck{\Pi}%
                \oftype%
                {\color{OIblue}\prod_{X\oftype\CatFont{U}}(\CatFont{T}(X)\to\CatFont{U})}%
                \mathbin{\color{OIvermillion}\to}%
                {\color{OIblue}\CatFont{U}}%
            \]%
            satisfying the judgemental equality
            \[
                \CatFont{T}\pig(\widecheck{\Pi}(X,Y)\pig)%
                \doteq%
                \prod_{x\oftype\CatFont{T}(X)}\CatFont{T}(Y(x))%
            \]%
            for each $X\oftype\CatFont{U}$ and each $Y\oftype\CatFont{T}(X)\to\CatFont{U}$.
        \item\label{universes-closure-under-dependent-pairs}\SloganFont{Closure Under Dependent Pairs. }There exists a function
            \[
                \widecheck{\Sigma}%
                \oftype%
                {\color{OIblue}\prod_{X\oftype\CatFont{U}}(\CatFont{T}(X)\to\CatFont{U})}%
                \mathbin{\color{OIvermillion}\to}%
                {\color{OIblue}\CatFont{U}}%
            \]%
            satisfying the judgemental equality
            \[
                \CatFont{T}\pig(\widecheck{\Sigma}(X,Y)\pig)%
                \doteq%
                \sum_{x\oftype\CatFont{T}(X)}\CatFont{T}(Y(x))%
            \]%
            for each $X\oftype\CatFont{U}$ and each $Y\oftype\CatFont{T}(X)\to\CatFont{U}$.
        \item\label{universes-closure-under-identity-types}\SloganFont{Closure Under Identity Types. }There exists a function
            \[
                \widecheck{\mrmI}%
                \oftype%
                {\color{OIblue}\prod_{X\oftype\CatFont{U}}\CatFont{T}(X)\times\CatFont{T}(X)}%
                \mathbin{\color{OIvermillion}\to}%
                {\color{OIblue}\CatFont{U}}%
            \]%
            satisfying the judgemental equality
            \[
                \CatFont{T}\pig(\widecheck{\mrmI}(X,x,y)\pig)%
                \doteq%
                (x\equals_{\CatFont{T}(X)}y)%
            \]%
            for each $X\oftype\CatFont{U}$ and each $x,y\oftype\CatFont{T}(X)$.
        \item\label{universes-closure-under-coproducts}\SloganFont{Closure Under Coproducts. }There exists a function
            \[
                \widecheck{\mathord{+}}%
                \oftype%
                \CatFont{U}\times\CatFont{U}%
                \to%
                \CatFont{U}%
            \]%
            satisfying the judgemental equality
            \[
                \CatFont{T}\pig(X\mathbin{\widecheck{\mathord{+}}}Y\pig)%
                \doteq%
                \CatFont{T}(X)+\CatFont{T}(Y)%
            \]%
            for each $X,Y\oftype\CatFont{U}$.
        \item\label{universes-closure-under-coproducts-existence-of-empty-types}\SloganFont{Existence of Empty Types. }The type $\CatFont{U}$ has a term $\widecheck{\EmptyType}$ satisfying the judgemental equality
            \[
                \CatFont{T}(\widecheck{\EmptyType})%
                \doteq%
                \EmptyType.%
            \]%
        \item\label{universes-closure-under-coproducts-existence-of-unit-types}\SloganFont{Existence of Unit Types. }The type $\CatFont{U}$ has a term $\widecheck{\UnitType}$ satisfying the judgemental equality
            \[
                \CatFont{T}(\widecheck{\UnitType})%
                \doteq%
                \UnitType.%
            \]%
        \item\label{universes-closure-under-coproducts-existence-of-natural-numbers}\SloganFont{Existence of Natural Numbers. }The type $\CatFont{U}$ has a term $\widecheck{\N}$ satisfying the judgemental equality
            \[
                \CatFont{T}(\widecheck{\N})%
                \doteq%
                \N.%
            \]%
    \end{enumerate}
\end{definition}
\begin{remark}{Assumption of Enough Universes}{assumption-of-enough-universes}%
    We assume that there exist \index[type-theory]{universe!assumption of enough universes}\textbf{enough universes} in the sense that given a finite list of types in context
    \begin{gather*}
        \Gamma_{1}\vdash A_{1}\type\\%
        \vdots\\%
        \Gamma_{n}\vdash A_{n}\type,%
    \end{gather*}
    there exists some universe $\CatFont{U}$ containing each $A_{i}$. In particular:
    \begin{enumerate}
        \item\label{assumption-of-enough-universes-the-base-universe}\SloganFont{The Base Universe. }The \index[type-theory]{base universe}\textbf{base universe} \index[notation]{Uzero@$\CatFont{U}_{0}$}$\CatFont{U}_{0}$ is the universe obtained via assuming enough universes for the empty context.
        \item\label{assumption-of-enough-universes-successor-universes}\SloganFont{Successor Universes. }The \index[type-theory]{successor universe}\textbf{successor universe} of a universe $\CatFont{U}$ is the universe \index[notation]{Uplus@$\CatFont{U}^{+}$}$\CatFont{U}^{+}$ obtained via assuming enough universes for the finite list
            \begin{align*}
                {\color{OIvermillion}}                    &\mathbin{\vdash} {\color{OIblue}\CatFont{U}\type}\\
                {\color{OIvermillion}X\oftype\CatFont{U}} &\mathbin{\vdash} {\color{OIblue}\CatFont{T}(X)\type}.
            \end{align*}
            The successor universe $\CatFont{U}^{+}$ of $\CatFont{U}$ contains $\CatFont{U}$ as well as every term of $\CatFont{U}$.
        \item\label{assumption-of-enough-universes-joins}\SloganFont{Joins. }The \index[type-theory]{universe!join of}\textbf{join} of universes $\CatFont{U}$ and $\CatFont{V}$ is the universe \index[notation]{UcoprodV@$\CatFont{U}\coprod\CatFont{V}$}$\CatFont{U}\coprod\CatFont{V}$ obtained via assuming enough universes for the finite list%
            %--- Begin Footnote ---%
            \footnote{%
                Since we don't postulate relations between universes, it may be the case that $(\CatFont{U}\coprod\CatFont{V})\coprod\CatFont{W}$ and $\CatFont{U}\coprod(\CatFont{V}\coprod\CatFont{W})$ are unrelated.
                \par\vspace*{\TCBBoxCorrection}
            }%
            %---  End Footnote  ---%
            \begin{align*}
                {\color{OIvermillion}X\oftype\CatFont{U}} &\mathbin{\vdash} {\color{OIblue}\CatFont{T}_{\CatFont{U}}(X)\type}\\
                {\color{OIvermillion}Y\oftype\CatFont{V}} &\mathbin{\vdash} {\color{OIblue}\CatFont{T}_{\CatFont{V}}(Y)\type},
            \end{align*}
            coming with maps
            \begin{align*}
                \iota_{\CatFont{U}} &\oftype \CatFont{U}\to\CatFont{U}\coprod\CatFont{V}\\
                \iota_{\CatFont{V}} &\oftype \CatFont{V}\to\CatFont{U}\coprod\CatFont{V}.
            \end{align*}
    \end{enumerate}
\end{remark}
\section{The Curry--Howard Correspondence}\label{section-the-curry-howard-correspondence}
\subsection{Foundations}\label{subsection-the-curry-howard-correspondence-foundations}
\begin{definition}{The Curry--Howard Correspondence}{the-curry-howard-correspondence}%
    The \index[type-theory]{Curry--Howard correspondence}\textbf{Curry--Howard correspondence} is the observation that one may think of:
    \begin{enumerate}
        \item\label{the-curry-howard-correspondence-types}Types as propositions (and vice-versa).
        \item\label{the-curry-howard-correspondence-terms}Terms as proofs (and vice-versa).
    \end{enumerate}
\end{definition}
\begin{example}{Divisibility}{divisibility-curry-howard-correspondence}%
    Let $d,n\oftype\N$.
    \begin{enumerate}
        \item\label{divisibility-curry-howard-correspondence-1}To express the statement that $d$ divides $n$, we define a \textit{type}
            \[
                d\mid n%
                \defeq%
                \sum_{k\oftype\N}(dk\equals_{\N}n)%
            \]%
            whose terms may then be thought of as \textit{witnesses} to the statement \say{$d$ divides $n$}.
        \item\label{divisibility-curry-howard-correspondence-2}To express the statement that $1_{\N}$ divides every natural number (universal quantification), we use Π-types:
            \[
                \prod_{x\oftype\N}(1_{\N}\mid x).%
            \]%
            To prove this statement, we must construct a term of this type, such as $\llbracket x\mapsto(x,\onemult_{\N}(x))\rrbracket$.
    \end{enumerate}
\end{example}
\begin{remark}{Table of Analogies in The Curry--Howard Correspondence}{}%
    The Curry--Howard correspondence between logic and type theory is summarised in the following table:
    \begingroup%
    \renewcommand{\arraystretch}{1.2}
    \begin{center}
        \begin{tabular}{|Sc|Sc|}\hline\rowcolor{darkRed}
            \textcolor{white}{\textbf{Logic}}            & \textcolor{white}{\textbf{Type Theory}} \\\hline\rowcolor{backgroundColor}
            Propositions $P$                             & Types $A$                               \\\rowcolor{black!05!backgroundColor}
            Proofs       $p$                             & Terms $a\oftype A$                      \\\rowcolor{backgroundColor}
            $\top$                                       & $\UnitType$                             \\\rowcolor{black!05!backgroundColor}
            $\bot$                                       & $\EmptyType$                            \\\rowcolor{backgroundColor}
            Disjunction $P\lor Q$                        & Coproduct types $A+B$                   \\\rowcolor{black!05!backgroundColor}
            Conjunction $P\land Q$                       & Product types $A\times B$               \\\rowcolor{backgroundColor}
            Implication $P\implies Q$                    & Function type $A\to B$                  \\\rowcolor{black!05!backgroundColor}
            Negation $\neg P$                            & Negation type $A\to\EmptyType$          \\\rowcolor{backgroundColor}
            Existential quantification $\exists_{x}P(x)$ & Σ-types $\sum_{x\oftype A}B(x)$         \\\rowcolor{black!05!backgroundColor}
            Universal quantification $\forall_{x}P(x)$   & Π-types $\prod_{x\oftype A}B(x)$        \\\rowcolor{backgroundColor}
            Equality $x=y$                               & Identity types $x\equals_{A}y$          \\\hline
        \end{tabular}
    \end{center}
    \endgroup
\end{remark}
\section{Decidability}\label{section-decidability}
\subsection{Foundations}\label{subsection-decidability-foundations}
\begin{definition}{Decidable Types}{decidable-types}%
    Let $A$ be a type and let $P$ be a type family indexed over $A$.
    \begin{enumerate}
        \item\label{decidable-types-decidable-types}The type $A$ is \index[type-theory]{decidable type}\textbf{decidable} if there is a term of type $A+\neg A$.%
        \item\label{decidable-types-decidable-type-families}The type family $P$ is \index[type-theory]{decidable type family}\textbf{decidable} if, for each $x\oftype A$, the type $P(x)$ is decidable.
    \end{enumerate}
\end{definition}
\begin{notation}{$\isdecidable(A)$}{is-decidable-A}%
    We write \index[notation]{isdecidableA@$\isdecidable(A)$}$\isdecidable(A)$ for the type defined by
    \[
        \isdecidable(A)%
        \defeq%
        A+\neg A.%
    \]%
\end{notation}
\begin{example}{Examples of Decidable Types}{examples-of-decidable-types}%
    Here are some examples of decidable types.
    \begin{enumerate}
        \item\label{examples-of-decidable-types-the-empty-type}The empty type $\EmptyType$ is decidable, as we may use $\id_{\EmptyType}$ to construct a term $\iota^{\rmR}_{\EmptyType+\neg\EmptyType}(\id_{\EmptyType})$ of type $\isdecidable(\EmptyType)$.
        \item\label{examples-of-decidable-types-the-unit-type}The unit type $\UnitType$ is decidable, as we may use $\point$ to construct a term $\iota^{\rmL}_{\UnitType+\neg\UnitType}(\point)$ of type $\isdecidable(\UnitType)$.
        \item\label{examples-of-decidable-types-the-natural-numbers}The type of natural numbers $\N$ is decidable, as we may use $0_{\N}$ to construct a term $\iota^{\rmL}_{\N+\neg\N}(0_{\N})$ of type $\isdecidable(\N)$.
        \item\label{examples-of-decidable-types-types-equipped-with-terms}More generally, any type that comes equipped with a term $a$ is decidable, as we may construct a term $\iota^{\rmL}_{A+\neg A}(a)$ of type $\isdecidable(A)$.
        \item\label{examples-of-decidable-types-observational-equality-on-natural-numbers}The type $\sfEq_{\N}(n,m)$ is decidable for all $n,m\oftype\N$. This is proven via induction, noting that the types
            \begin{gather*}
                \sfEq_{\N}(0_{\N},0_{\N})\doteq\UnitType,\\%
                \begin{aligned}
                    \sfEq_{\N}(0_{\N},\succ_{\N}(m)) &\doteq \EmptyType,\\
                    \sfEq_{\N}(\succ_{\N}(n),0_{\N}) &\doteq \EmptyType
                \end{aligned}
            \end{gather*}
            are decidable, and that so is the type
            \[
                \sfEq_{\N}(\succ_{\N}(n),\succ_{\N}(m))%
                \doteq%
                \sfEq_{\N}(n,m)%
            \]%
            by the inductive hypothesis.
    \end{enumerate}
\end{example}
\begin{proposition}{Properties of Decidable Types}{properties-of-decidable-types}%
    Let $A$ and $B$ be types.
    \begin{enumerate}
        \item\label{properties-of-decidable-types-decidability-of-dependent-pairs}\SloganFont{Decidability of Dependent Pairs. }If $A$ and $B$ are decidable, then so is $A+B$.
        \item\label{properties-of-decidable-types-decidability-of-products}\SloganFont{Decidability of Products. }If $A$ and $B$ are decidable, then so is $A\times B$.
        \item\label{properties-of-decidable-types-decidability-of-function-types}\SloganFont{Decidability of Function Types. }If $A$ and $B$ are decidable, then so is $A\to B$.
        \item\label{properties-of-decidable-types-decidability-of-negations-of-types}\SloganFont{Decidability of Negations of Types. }If $A$ is decidable, then so is $\neg A$.
        \item\label{properties-of-decidable-types-interaction-with-bi-implications}\SloganFont{Interaction With Bi-Implications. }If $A\biimplications B$ is inhabited, then the following conditions are equivalent:
            \begin{enumerate}
                \item\label{properties-of-decidable-types-interaction-with-bi-implications-a}The type $A$ is decidable.
                \item\label{properties-of-decidable-types-interaction-with-bi-implications-b}The type $B$ is decidable.
            \end{enumerate}
        %\item\label{properties-of-decidable-types-}\SloganFont{. }
    \end{enumerate}
\end{proposition}
\begin{Proof}{Proof of \cref{properties-of-decidable-types}}%
    \FirstProofBox{\cref{properties-of-decidable-types-decidability-of-dependent-pairs}: Decidability of Dependent Pairs}%
    Given a term $a\oftype A$ or $f\oftype A\to\EmptyType$ and a term $b\oftype B$ or $g\oftype B\to\EmptyType$, we construct a term of type $\isdecidable(A+B)$ as follows:
    \begingroup%
    \renewcommand{\arraystretch}{1.2}
    \begin{center}
        \begin{tabular}{|Sc|Sc|Sc|}\hline\rowcolor{darkRed}
            $\isdecidable(A)$            & $\isdecidable(B)$            & $\isdecidable(A+B)$                                         \\\hline\rowcolor{backgroundColor}
            $\iota^{\rmL}_{A+\neg A}(a)$ & $\iota^{\rmL}_{B+\neg B}(b)$ & $\iota^{rmL}_{(A+B)+\neg(A+B)}(\iota^{\rmL}_{A+\neg A}(a))$ \\\rowcolor{black!05!backgroundColor}
            $\iota^{\rmL}_{A+\neg A}(a)$ & $\iota^{\rmR}_{B+\neg B}(g)$ & $\iota^{rmR}_{(A+B)+\neg(A+B)}(\iota^{\rmL}_{A+\neg A}(a))$ \\\rowcolor{backgroundColor}
            $\iota^{\rmR}_{A+\neg A}(f)$ & $\iota^{\rmL}_{B+\neg B}(b)$ & $\iota^{rmL}_{(A+B)+\neg(A+B)}(\iota^{\rmR}_{B+\neg B}(g))$ \\\rowcolor{black!05!backgroundColor}
            $\iota^{\rmR}_{A+\neg A}(f)$ & $\iota^{\rmR}_{B+\neg B}(g)$ & $\iota^{rmR}_{(A+B)+\neg(A+B)}([f,g])$                      \\\hline
        \end{tabular}
    \end{center}
    \endgroup
    This finishes the proof.

    \ProofBox{\cref{properties-of-decidable-types-decidability-of-products}: Decidability of Products}%
    Given a term $a\oftype A$ or $f\oftype A\to\EmptyType$ and a term $b\oftype B$ or $g\oftype B\to\EmptyType$, we construct a term of type $\isdecidable(A\times B)$ as follows:
    \begingroup%
    \renewcommand{\arraystretch}{1.2}
    \begin{center}
        \begin{tabular}{|Sc|Sc|Sc|}\hline\rowcolor{darkRed}
            $\isdecidable(A)$            & $\isdecidable(B)$            & $\isdecidable(A\times B)$                                              \\\hline\rowcolor{backgroundColor}
            $\iota^{\rmL}_{A+\neg A}(a)$ & $\iota^{\rmL}_{B+\neg B}(b)$ & $\iota^{rmL}_{(A\times B)+\neg(A\times B)}(a,b)$                       \\\rowcolor{black!05!backgroundColor}
            $\iota^{\rmL}_{A+\neg A}(a)$ & $\iota^{\rmR}_{B+\neg B}(g)$ & $\iota^{rmR}_{(A\times B)+\neg(A\times B)}(g\circ\pr^{A\times B}_{2})$ \\\rowcolor{backgroundColor}
            $\iota^{\rmR}_{A+\neg A}(f)$ & $\iota^{\rmL}_{B+\neg B}(b)$ & $\iota^{rmL}_{(A\times B)+\neg(A\times B)}(f\circ\pr^{A\times B}_{1})$ \\\rowcolor{black!05!backgroundColor}
            $\iota^{\rmR}_{A+\neg A}(f)$ & $\iota^{\rmR}_{B+\neg B}(g)$ & $\iota^{rmR}_{(A\times B)+\neg(A\times B)}(f\circ\pr^{A\times B}_{1})$ \\\hline
        \end{tabular}
    \end{center}
    \endgroup
    This finishes the proof.

    \ProofBox{\cref{properties-of-decidable-types-decidability-of-function-types}: Decidability of Function Types}%
    Given a term $a\oftype A$ or $f\oftype A\to\EmptyType$ and a term $b\oftype B$ or $g\oftype B\to\EmptyType$, we construct a term of type $\isdecidable(A+B)$ as follows:
    \begingroup%
    \renewcommand{\arraystretch}{1.2}
    \begin{center}
        \begin{tabular}{|Sc|Sc|Sc|}\hline\rowcolor{darkRed}
            $\isdecidable(A)$            & $\isdecidable(B)$            & $\isdecidable(A\to B)$                                                                                  \\\hline\rowcolor{backgroundColor}
            $\iota^{\rmL}_{A+\neg A}(a)$ & $\iota^{\rmL}_{B+\neg B}(b)$ & $\iota^{rmL}_{(A\to B)+\neg(A\to B)}(\llbracket x\mapsto b\rrbracket)$                                  \\\rowcolor{black!05!backgroundColor}
            $\iota^{\rmL}_{A+\neg A}(a)$ & $\iota^{\rmR}_{B+\neg B}(g)$ & $\iota^{rmR}_{(A\to B)+\neg(A\to B)}(\llbracket[A\xlongrightarrow{\phi}B]\mapsto g(\phi(a))\rrbracket)$ \\\rowcolor{backgroundColor}
            $\iota^{\rmR}_{A+\neg A}(f)$ & $\iota^{\rmL}_{B+\neg B}(b)$ & $\iota^{rmL}_{(A\to B)+\neg(A\to B)}(\exfalso\circ f)$                                                  \\\rowcolor{black!05!backgroundColor}
            $\iota^{\rmR}_{A+\neg A}(f)$ & $\iota^{\rmR}_{B+\neg B}(g)$ & $\iota^{rmR}_{(A\to B)+\neg(A\to B)}(\exfalso\circ f)$                                                  \\\hline
        \end{tabular}
    \end{center}
    \endgroup
    This finishes the proof.

    \ProofBox{\cref{properties-of-decidable-types-decidability-of-negations-of-types}: Decidability of Negations of Types}%
    This follows from \cref{properties-of-decidable-types-decidability-of-function-types} and the fact that $\EmptyType$ is decidable.

    \ProofBox{\cref{properties-of-decidable-types-interaction-with-bi-implications}: Interaction With Bi-Implications}%
    By \cref{properties-of-negations-of-types-contrapositive} of \cref{properties-of-negations-of-types}, we can assign to every pair of functions $f\oftype A\to B$ and $g\oftype B\to A$ functions
    \begin{align*}
        \widetilde{f} &\oftype\neg B\to\neg A,\\
        \widetilde{g} &\oftype\neg A\to\neg B.
    \end{align*}
    We may then build functions
    \begin{align*}
        f+\widetilde{g} &\oftype (A+\neg A)\to(B+\neg B),\\
        g+\widetilde{f} &\oftype (B+\neg B)\to(A+\neg A).
    \end{align*}
    This finishes the proof.
\end{Proof}
\subsection{Decidable Equality}\label{subsection-decidable-equality}
\begin{definition}{Decidable Equality}{decidable-equality}%
    A type $A$ \index[type-theory]{decidable equality}\textbf{has decidable equality} if the identity type $x\equals_{A}y$ is decidable for each $x,y\oftype A$.
\end{definition}
\begin{notation}{$\hasdecidableeq(A)$}{has-decidable-eq-A}%
    We write \index[notation]{hasdecidableeqA@$\hasdecidableeq(A)$}$\hasdecidableeq(A)$ for the type defined by
    \[
        \hasdecidableeq(A)%
        \defeq%
        \prod_{x,y\oftype A}\isdecidable(x\equals_{A}y).%
    \]%
\end{notation}
\begin{example}{Types With Decidable Equality}{types-with-decidable-equality}%
    Here are some examples of types with decidable equality.
    \begin{enumerate}
        \item\label{types-with-decidable-equality-the-natural-numbers}The type of natural numbers $\N$ has decidable equality via \cref{examples-of-decidable-types-observational-equality-on-natural-numbers} of \cref{examples-of-decidable-types} and \cref{properties-of-observational-equality-of-natural-numbers-relation-to-identity-types} of \cref{properties-of-observational-equality-of-natural-numbers}.
    \end{enumerate}
\end{example}
\begin{appendices}
\input{ABSOLUTEPATH/chapters2.tex}
\end{appendices}
\end{document}
